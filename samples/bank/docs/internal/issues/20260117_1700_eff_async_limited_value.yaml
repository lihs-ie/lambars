# eff_async! マクロの適用範囲の限界
#
# 概要:
#   現在のbank sampleのコードベースにおいて、eff_async!マクロの
#   適用が期待したほどの価値を提供しない理由を記録
#
# 結論:
#   Phase 3をスキップし、Phase 4（Readerモナド）に進む

version: "1.0.0"
name: "eff_async_limited_value"
status: "deferred"
created_at: "2026-01-17T17:00:00+09:00"

# 背景
background:
  original_plan: |
    ロードマップのPhase 3では、eff!マクロ（eff_async!）によるワークフロー記述を
    計画していた。これにより、do-notationスタイルでAsyncIO操作を記述し、
    複雑な非同期ワークフローの可読性を向上させることを目指していた。

  discovery: |
    実装を検討した結果、現在のコードベースでは期待したほどの
    価値が得られないことが判明した。

# 問題点
issues:
  - id: result_wrapping
    title: "Result型のラッピング問題"
    description: |
      現在のAsyncIO操作はすべて `AsyncIO<Result<T, E>>` を返す。

      eff_async! でバインドすると:
      ```rust
      eff_async! {
          result <= some_async_operation();  // result は Result<T, E>
          // ここで T を直接扱えない
      }
      ```

      内部の T を取り出すには追加のマッチングやエラーハンドリングが必要で、
      現在の `?` 演算子パターンより複雑になる。

  - id: idiomatic_rust
    title: "Rustイディオムとの競合"
    description: |
      Rustでは `?` 演算子による早期リターンが標準的なエラー処理パターン:
      ```rust
      let events = event_store
          .load_events(&account_id)
          .run_async()
          .await
          .map_err(|e| event_store_error_response(&e))?;
      ```

      これは既に十分に簡潔で読みやすく、Rust開発者に馴染みがある。

  - id: monad_transformer_needed
    title: "モナドトランスフォーマーの必要性"
    description: |
      eff_async! で Result を透過的に扱うには ExceptT のような
      モナドトランスフォーマーが必要。しかし:

      1. ExceptT は存在するが AsyncIO との組み合わせは複雑
      2. Rust の型システムでは型推論が困難になる場合がある
      3. 追加の学習コストに見合うメリットが少ない

# 代替案の検討
alternatives_considered:
  - id: pure_asyncio
    description: |
      AsyncIO<T> を返す関数に変更し、エラーを別の方法で処理する。
    rejected_reason: |
      エラー処理のベストプラクティスに反する。
      Result型でエラーを表現することはRustの重要なイディオム。

  - id: except_transformer
    description: |
      ExceptT<E, AsyncIO<Result<A, E>>> を使用する。
    rejected_reason: |
      型が複雑になり、読みやすさが低下する。
      Rust開発者にとって直感的でない。

  - id: status_quo
    description: |
      現在の `.run_async().await?` パターンを維持する。
    accepted_reason: |
      - イディオマティックなRust
      - 十分に簡潔
      - エラー追跡が明確
      - 追加の学習コストなし

# 今後の対応
future_considerations:
  - id: revisit_when_needed
    description: |
      以下の場合に再検討:
      1. lambarsにAsyncIO用のExceptTが追加された場合
      2. より複雑なワークフローが必要になった場合
      3. Rustにdo-notationが導入された場合

  - id: document_pattern
    description: |
      現在のパイプラインパターン（Phase 2で実装済み）を
      ドキュメントで推奨パターンとして記載する。

# 関連
related:
  - "docs/internal/plans/20260117_1500_lambars_full_utilization_roadmap.yaml"
  - "src/api/handlers/transaction.rs"
  - "src/infrastructure/event_store.rs"

# 解決策の提案
resolution_proposal:
  issue: "docs/internal/issues/20260117_1800_exceptt_asyncio_support.yaml"
  description: |
    ExceptT に AsyncIO サポートを追加することで、この問題を解決できる可能性がある。
    ExceptT<E, AsyncIO<Result<A, E>>> の flat_map が実装されれば、
    eff_async! マクロで透過的なエラーハンドリングが可能になる。
