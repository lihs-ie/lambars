# Infrastructure Design: Database
# Project: Dungeon of Pure Functions
# Component: MySQL + Redis

metadata:
  version: "1.0.0"
  created_at: "2026-01-09"
  updated_at: "2026-01-09"
  status: draft

# =============================================================================
# Design Principles
# =============================================================================

design_principles:
  - name: UUID Storage Optimization
    description: UUID を BINARY(16) で格納し、VARCHAR(36) より効率的に

  - name: Normalized Columns for Frequent Queries
    description: 頻繁に検索・フィルタするフィールドは正規化カラムに

  - name: JSON for Complex Structures
    description: 永続データ構造やネストした値オブジェクトは JSON カラムに

  - name: Event Sourcing Compliance
    description: イベントは追記のみ、変更・削除不可

# =============================================================================
# MySQL Schema
# =============================================================================

mysql:
  tables:
    # -------------------------------------------------------------------------
    # game_sessions - ゲームセッション（集約ルート）
    # -------------------------------------------------------------------------
    - name: game_sessions
      description: ゲームセッションの主要情報を格納
      aggregate: GameSession

      columns:
        - name: game_id
          type: BINARY(16)
          constraints: [PRIMARY KEY]
          mapping:
            aggregate_field: identifier
            conversion: UUID → bytes

        - name: player_id
          type: BINARY(16)
          constraints: [NOT NULL]
          mapping:
            aggregate_field: player.identifier
            conversion: UUID → bytes

        - name: current_floor_level
          type: INT UNSIGNED
          constraints: [NOT NULL, DEFAULT 1]
          mapping:
            aggregate_field: current_floor.level
            conversion: FloorLevel.0

        - name: turn_count
          type: BIGINT UNSIGNED
          constraints: [NOT NULL, DEFAULT 0]
          mapping:
            aggregate_field: turn_count
            conversion: TurnCount.0

        - name: status
          type: "ENUM('in_progress', 'victory', 'defeat', 'paused')"
          constraints: [NOT NULL, DEFAULT 'in_progress']
          mapping:
            aggregate_field: status
            conversion: GameStatus → ENUM variant name

        - name: random_seed
          type: BIGINT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            aggregate_field: seed
            conversion: RandomSeed.0

        - name: event_sequence
          type: BIGINT UNSIGNED
          constraints: [NOT NULL, DEFAULT 0]
          mapping:
            aggregate_field: event_sequence
            conversion: 直接マッピング

        - name: created_at
          type: TIMESTAMP(6)
          constraints: [NOT NULL, DEFAULT CURRENT_TIMESTAMP(6)]
          mapping:
            aggregate_field: metadata.created_at

        - name: updated_at
          type: TIMESTAMP(6)
          constraints: [NOT NULL, DEFAULT CURRENT_TIMESTAMP(6), ON UPDATE CURRENT_TIMESTAMP(6)]
          mapping:
            aggregate_field: metadata.updated_at

      indexes:
        - name: idx_player_id
          columns: [player_id]
        - name: idx_status
          columns: [status]
        - name: idx_created_at
          columns: [created_at]

    # -------------------------------------------------------------------------
    # players - プレイヤー
    # -------------------------------------------------------------------------
    - name: players
      description: プレイヤーの状態を格納
      aggregate: Player

      columns:
        - name: player_id
          type: BINARY(16)
          constraints: [PRIMARY KEY]
          mapping:
            aggregate_field: identifier
            conversion: UUID → bytes

        - name: game_id
          type: BINARY(16)
          constraints: [NOT NULL, "FOREIGN KEY → game_sessions(game_id) ON DELETE CASCADE"]
          mapping:
            aggregate_field: "外部参照"

        - name: name
          type: VARCHAR(50)
          constraints: [NOT NULL]
          mapping:
            aggregate_field: name
            conversion: PlayerName.0

        - name: position_x
          type: INT
          constraints: [NOT NULL]
          mapping:
            aggregate_field: position.x
            conversion: Position.x

        - name: position_y
          type: INT
          constraints: [NOT NULL]
          mapping:
            aggregate_field: position.y
            conversion: Position.y

        - name: current_health
          type: INT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            aggregate_field: stats.health.current
            conversion: Health.current

        - name: max_health
          type: INT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            aggregate_field: stats.health.max
            conversion: Health.max

        - name: current_mana
          type: INT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            aggregate_field: stats.mana.current
            conversion: Mana.current

        - name: max_mana
          type: INT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            aggregate_field: stats.mana.max
            conversion: Mana.max

        - name: level
          type: TINYINT UNSIGNED
          constraints: [NOT NULL, DEFAULT 1]
          mapping:
            aggregate_field: level
            conversion: Level.0

        - name: experience
          type: BIGINT UNSIGNED
          constraints: [NOT NULL, DEFAULT 0]
          mapping:
            aggregate_field: experience
            conversion: Experience.0

        - name: base_stats
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: base_stats
            conversion: BaseStats → JSON
          json_schema:
            type: object
            properties:
              strength: { type: integer }
              dexterity: { type: integer }
              intelligence: { type: integer }
              vitality: { type: integer }

        - name: combat_stats
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: "combat_stats (attack, defense, speed のみ)"
            conversion: CombatStats → JSON
          json_schema:
            type: object
            properties:
              attack: { type: integer }
              defense: { type: integer }
              speed: { type: integer }

        - name: equipment_slots
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: equipment
            conversion: EquipmentSlots → JSON
          json_schema:
            type: object
            properties:
              weapon: { "$ref": "#/definitions/Item", nullable: true }
              armor: { "$ref": "#/definitions/Item", nullable: true }
              helmet: { "$ref": "#/definitions/Item", nullable: true }
              accessory: { "$ref": "#/definitions/Item", nullable: true }

        - name: inventory
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: inventory.items
            conversion: PersistentVector<ItemStack> → JSON array
          json_schema:
            type: array
            items:
              type: object
              properties:
                item: { "$ref": "#/definitions/Item" }
                quantity: { type: integer, minimum: 1 }

        - name: status_effects
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: status_effects
            conversion: PersistentVector<StatusEffect> → JSON array
          json_schema:
            type: array
            items:
              type: object
              properties:
                effect_type: { type: string }
                remaining_turns: { type: integer }
                magnitude: { type: number }

      indexes:
        - name: idx_game_id
          columns: [game_id]

    # -------------------------------------------------------------------------
    # floors - フロア
    # -------------------------------------------------------------------------
    - name: floors
      description: ダンジョンフロアの情報を格納
      aggregate: Floor

      columns:
        - name: floor_id
          type: BINARY(16)
          constraints: [PRIMARY KEY]
          mapping:
            aggregate_field: identifier
            conversion: UUID → bytes

        - name: game_id
          type: BINARY(16)
          constraints: [NOT NULL, "FOREIGN KEY → game_sessions(game_id) ON DELETE CASCADE"]

        - name: level
          type: INT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            aggregate_field: level
            conversion: FloorLevel.0

        - name: width
          type: INT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            aggregate_field: width

        - name: height
          type: INT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            aggregate_field: height

        - name: stairs_up_x
          type: INT
          constraints: [NULLABLE]
          mapping:
            aggregate_field: stairs_up.x
            conversion: "Option<Position>.map(|p| p.x)"

        - name: stairs_up_y
          type: INT
          constraints: [NULLABLE]
          mapping:
            aggregate_field: stairs_up.y
            conversion: "Option<Position>.map(|p| p.y)"

        - name: stairs_down_x
          type: INT
          constraints: [NULLABLE]
          mapping:
            aggregate_field: stairs_down.x
            conversion: "Option<Position>.map(|p| p.x)"

        - name: stairs_down_y
          type: INT
          constraints: [NULLABLE]
          mapping:
            aggregate_field: stairs_down.y
            conversion: "Option<Position>.map(|p| p.y)"

        - name: tiles
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: tiles
            conversion: PersistentVector<PersistentVector<Tile>> → JSON 2D array
          json_schema:
            type: array
            items:
              type: array
              items:
                type: object
                properties:
                  kind: { type: string, enum: [Floor, Wall, Door, StairsUp, StairsDown, Trap] }
                  is_explored: { type: boolean }
                  is_visible: { type: boolean }
                  door_is_open: { type: boolean, nullable: true }
                  trap_type: { type: string, nullable: true }

        - name: rooms
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: rooms
            conversion: PersistentVector<Room> → JSON array
          json_schema:
            type: array
            items:
              type: object
              properties:
                top_left: { type: object, properties: { x: { type: integer }, y: { type: integer } } }
                width: { type: integer }
                height: { type: integer }

        - name: corridors
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: corridors
            conversion: PersistentVector<Corridor> → JSON array

        - name: spawn_points
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: spawn_points
            conversion: PersistentVector<Position> → JSON array
          json_schema:
            type: array
            items:
              type: object
              properties:
                x: { type: integer }
                y: { type: integer }

      indexes:
        - name: idx_game_id
          columns: [game_id]
        - name: uk_game_floor
          columns: [game_id, level]
          unique: true

    # -------------------------------------------------------------------------
    # enemies - 敵
    # -------------------------------------------------------------------------
    - name: enemies
      description: 敵キャラクターの情報を格納
      aggregate: Enemy

      columns:
        - name: enemy_id
          type: BINARY(16)
          constraints: [PRIMARY KEY]
          mapping:
            aggregate_field: identifier
            conversion: UUID → bytes

        - name: game_id
          type: BINARY(16)
          constraints: [NOT NULL, "FOREIGN KEY → game_sessions(game_id) ON DELETE CASCADE"]

        - name: floor_level
          type: INT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            aggregate_field: "外部参照 - 所属フロア"

        - name: enemy_type
          type: VARCHAR(50)
          constraints: [NOT NULL]
          mapping:
            aggregate_field: enemy_type
            conversion: "EnemyType variant name (Goblin, Skeleton, etc.)"

        - name: position_x
          type: INT
          constraints: [NOT NULL]
          mapping:
            aggregate_field: position.x

        - name: position_y
          type: INT
          constraints: [NOT NULL]
          mapping:
            aggregate_field: position.y

        - name: current_health
          type: INT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            aggregate_field: stats.health.current

        - name: max_health
          type: INT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            aggregate_field: stats.health.max

        - name: is_alive
          type: BOOLEAN
          constraints: [NOT NULL, DEFAULT TRUE]
          mapping:
            aggregate_field: "derived: stats.health.current > 0"

        - name: combat_stats
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: stats
            conversion: CombatStats → JSON

        - name: behavior
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: behavior
            conversion: AiBehavior → JSON
          json_schema:
            type: object
            properties:
              pattern: { type: string, enum: [Aggressive, Defensive, Patrol, Flee] }
              detection_range: { type: integer }
              attack_range: { type: integer }
              flee_threshold: { type: number }

        - name: loot_table
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: loot_table
            conversion: LootTable → JSON

        - name: status_effects
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: status_effects
            conversion: PersistentVector<StatusEffect> → JSON array

      indexes:
        - name: idx_game_id
          columns: [game_id]
        - name: idx_game_floor
          columns: [game_id, floor_level]
        - name: idx_alive
          columns: [game_id, is_alive]

    # -------------------------------------------------------------------------
    # game_events - イベントストア
    # -------------------------------------------------------------------------
    - name: game_events
      description: Event Sourcing のイベントストア
      aggregate: GameEvent

      columns:
        - name: event_id
          type: BIGINT UNSIGNED
          constraints: [PRIMARY KEY, AUTO_INCREMENT]

        - name: game_id
          type: BINARY(16)
          constraints: [NOT NULL, "FOREIGN KEY → game_sessions(game_id) ON DELETE CASCADE"]
          mapping:
            aggregate_field: "外部参照"

        - name: sequence_number
          type: BIGINT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            aggregate_field: "イベントのシーケンス番号"

        - name: event_type
          type: VARCHAR(100)
          constraints: [NOT NULL]
          mapping:
            aggregate_field: GameEvent variant name
            conversion: "GameStarted, PlayerMoved, EnemyDied, etc."

        - name: aggregate_type
          type: VARCHAR(50)
          constraints: [NOT NULL]
          mapping:
            aggregate_field: 対象の集約種別
            conversion: "GameSession, Player, Enemy, Floor"

        - name: aggregate_id
          type: BINARY(16)
          constraints: [NOT NULL]
          mapping:
            aggregate_field: 対象集約の識別子

        - name: event_data
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: イベントのペイロード
            conversion: GameEvent の各 variant のフィールド → JSON
          json_schema_examples:
            PlayerMoved:
              type: object
              properties:
                from: { type: object, properties: { x: { type: integer }, y: { type: integer } } }
                to: { type: object, properties: { x: { type: integer }, y: { type: integer } } }
            PlayerAttacked:
              type: object
              properties:
                target: { type: string, description: "EntityId as hex string" }
                damage: { type: integer }
            EnemyDied:
              type: object
              properties:
                enemy_id: { type: string }
                loot: { type: array, items: { "$ref": "#/definitions/Item" } }

        - name: occurred_at
          type: TIMESTAMP(6)
          constraints: [NOT NULL, DEFAULT CURRENT_TIMESTAMP(6)]

      indexes:
        - name: uk_game_sequence
          columns: [game_id, sequence_number]
          unique: true
        - name: idx_game_aggregate
          columns: [game_id, aggregate_type, aggregate_id]
        - name: idx_occurred_at
          columns: [occurred_at]

    # -------------------------------------------------------------------------
    # game_snapshots - スナップショット
    # -------------------------------------------------------------------------
    - name: game_snapshots
      description: パフォーマンス最適化のためのスナップショット

      columns:
        - name: snapshot_id
          type: BIGINT UNSIGNED
          constraints: [PRIMARY KEY, AUTO_INCREMENT]

        - name: game_id
          type: BINARY(16)
          constraints: [NOT NULL, "FOREIGN KEY → game_sessions(game_id) ON DELETE CASCADE"]

        - name: sequence_number
          type: BIGINT UNSIGNED
          constraints: [NOT NULL]
          mapping:
            description: "スナップショット時点のイベントシーケンス番号"

        - name: state_data
          type: JSON
          constraints: [NOT NULL]
          mapping:
            aggregate_field: GameSession 全体の状態
            conversion: 全集約をネストした JSON
          json_schema:
            type: object
            properties:
              game_session:
                type: object
                description: GameSession の全フィールド
              player:
                type: object
                description: Player の全フィールド
              floor:
                type: object
                description: 現在 Floor の全フィールド
              enemies:
                type: array
                items:
                  type: object
                  description: Enemy の全フィールド

        - name: created_at
          type: TIMESTAMP(6)
          constraints: [NOT NULL, DEFAULT CURRENT_TIMESTAMP(6)]

      indexes:
        - name: idx_game_sequence
          columns: [game_id, sequence_number DESC]

    # -------------------------------------------------------------------------
    # leaderboard - リーダーボード
    # -------------------------------------------------------------------------
    - name: leaderboard
      description: ゲーム終了時のスコアランキング

      columns:
        - name: entry_id
          type: BIGINT UNSIGNED
          constraints: [PRIMARY KEY, AUTO_INCREMENT]

        - name: player_name
          type: VARCHAR(50)
          constraints: [NOT NULL]

        - name: game_id
          type: BINARY(16)
          constraints: [NOT NULL]

        - name: score
          type: BIGINT UNSIGNED
          constraints: [NOT NULL]

        - name: dungeon_depth
          type: INT UNSIGNED
          constraints: [NOT NULL]

        - name: turns_survived
          type: BIGINT UNSIGNED
          constraints: [NOT NULL]

        - name: enemies_defeated
          type: INT UNSIGNED
          constraints: [NOT NULL]

        - name: outcome
          type: "ENUM('victory', 'defeat')"
          constraints: [NOT NULL]

        - name: completed_at
          type: TIMESTAMP(6)
          constraints: [NOT NULL]

      indexes:
        - name: idx_score
          columns: [score DESC]
        - name: idx_completed_at
          columns: [completed_at DESC]
        - name: idx_outcome_score
          columns: [outcome, score DESC]

  # ---------------------------------------------------------------------------
  # Migration Files
  # ---------------------------------------------------------------------------
  migrations:
    - file: 001_initial_schema.sql
      description: game_sessions, players, floors, enemies テーブル作成

    - file: 002_event_store.sql
      description: game_events, game_snapshots テーブル作成

    - file: 003_leaderboard.sql
      description: leaderboard テーブル作成

    - file: 004_indexes.sql
      description: 追加インデックス最適化

# =============================================================================
# Redis Design
# =============================================================================

redis:
  serialization:
    primary: bincode
    description: |
      bincode は Rust ネイティブで最高のパフォーマンス。
      開発環境では JSON も選択可能（feature flag で切替）。
    comparison:
      - format: bincode
        size: smallest
        speed: fastest
        human_readable: false
        recommended: true

      - format: JSON
        size: large
        speed: slow
        human_readable: true
        use_case: development/debugging

      - format: MessagePack
        size: medium
        speed: medium
        human_readable: false
        use_case: alternative

  key_naming:
    pattern: "{env}:roguelike:{domain}:{resource_type}:{identifier}"
    prefixes:
      - name: dev
        description: 開発環境
      - name: prod
        description: 本番環境
      - name: test
        description: テスト環境

  data_stores:
    # -------------------------------------------------------------------------
    # Session Cache
    # -------------------------------------------------------------------------
    - name: SessionCache
      description: アクティブなゲームセッションのキャッシュ
      key_pattern: "{env}:roguelike:session:{game_id}"
      data_structure: "String (bytes)"
      ttl: 3600  # 1 hour
      serialization: bincode

      cached_structure:
        name: CachedGameSession
        fields:
          - name: game_id
            type: "[u8; 16]"
            description: UUID bytes
          - name: player
            type: CachedPlayer
          - name: current_floor
            type: CachedFloor
          - name: enemies
            type: "Vec<CachedEnemy>"
          - name: turn_count
            type: u64
          - name: status
            type: u8
            description: GameStatus enum discriminant
          - name: seed
            type: u64
          - name: event_sequence
            type: u64

      size_estimate:
        base_info: "~100 bytes"
        player: "~500 bytes"
        floor_50x50: "~10KB"
        enemies_20: "~2KB"
        total: "~15KB per session"

      port_interface:
        trait_name: SessionCache
        methods:
          - name: get
            signature: "fn get(&self, game_id: &GameIdentifier) -> AsyncIO<Option<GameSession>>"
            redis_operation: "GET {env}:roguelike:session:{game_id}"

          - name: set
            signature: "fn set(&self, game_id: &GameIdentifier, session: &GameSession, ttl: Duration) -> AsyncIO<()>"
            redis_operation: "SET {env}:roguelike:session:{game_id} {data} EX {ttl}"

          - name: invalidate
            signature: "fn invalidate(&self, game_id: &GameIdentifier) -> AsyncIO<()>"
            redis_operation: "DEL {env}:roguelike:session:{game_id}"

          - name: exists
            signature: "fn exists(&self, game_id: &GameIdentifier) -> AsyncIO<bool>"
            redis_operation: "EXISTS {env}:roguelike:session:{game_id}"

    # -------------------------------------------------------------------------
    # Turn Lock
    # -------------------------------------------------------------------------
    - name: TurnLock
      description: ターン処理の分散ロック
      key_pattern: "{env}:roguelike:lock:turn:{game_id}"
      data_structure: String
      ttl: 30  # 30 seconds
      serialization: "none (UUID string)"

      lock_structure:
        fields:
          - name: lock_id
            type: String
            description: UUID 文字列（所有者識別）
          - name: acquired_at
            type: i64
            description: Unix timestamp

      operations:
        acquire: "SET {env}:roguelike:lock:turn:{game_id} {lock_id} NX EX 30"
        release: "Lua script (CAS - compare and swap)"
        extend: "Lua script (TTL extension)"

      lua_scripts:
        release: |
          local lock_id = redis.call('GET', KEYS[1])
          if lock_id == ARGV[1] then
              return redis.call('DEL', KEYS[1])
          else
              return 0
          end

        extend: |
          local lock_id = redis.call('GET', KEYS[1])
          if lock_id == ARGV[1] then
              return redis.call('EXPIRE', KEYS[1], ARGV[2])
          else
              return 0
          end

      port_interface:
        trait_name: TurnLock
        methods:
          - name: acquire
            signature: "fn acquire(&self, game_id: &GameIdentifier, ttl: Duration) -> AsyncIO<Option<LockId>>"

          - name: release
            signature: "fn release(&self, game_id: &GameIdentifier, lock_id: &LockId) -> AsyncIO<bool>"

          - name: extend
            signature: "fn extend(&self, game_id: &GameIdentifier, lock_id: &LockId, ttl: Duration) -> AsyncIO<bool>"

    # -------------------------------------------------------------------------
    # Temporary Data Cache
    # -------------------------------------------------------------------------
    - name: TemporaryDataCache
      description: ターン中の一時データキャッシュ
      key_pattern: "{env}:roguelike:temp:{game_id}:{key}"
      data_structure: "String (bytes)"
      ttl: 300  # 5 minutes
      serialization: bincode

      port_interface:
        trait_name: TemporaryDataCache
        methods:
          - name: get
            signature: "fn get<T: DeserializeOwned>(&self, game_id: &GameIdentifier, key: &str) -> AsyncIO<Option<T>>"

          - name: set
            signature: "fn set<T: Serialize>(&self, game_id: &GameIdentifier, key: &str, value: &T, ttl: Duration) -> AsyncIO<()>"

          - name: delete
            signature: "fn delete(&self, game_id: &GameIdentifier, key: &str) -> AsyncIO<()>"

    # -------------------------------------------------------------------------
    # Active Session Registry
    # -------------------------------------------------------------------------
    - name: ActiveSessionRegistry
      description: アクティブなセッション一覧
      key_pattern: "{env}:roguelike:active_sessions"
      data_structure: Set
      ttl: none
      serialization: game_id strings

      port_interface:
        trait_name: ActiveSessionRegistry
        methods:
          - name: register
            signature: "fn register(&self, game_id: &GameIdentifier) -> AsyncIO<()>"
            redis_operation: "SADD {env}:roguelike:active_sessions {game_id}"

          - name: unregister
            signature: "fn unregister(&self, game_id: &GameIdentifier) -> AsyncIO<()>"
            redis_operation: "SREM {env}:roguelike:active_sessions {game_id}"

          - name: list_all
            signature: "fn list_all(&self) -> AsyncIO<Vec<GameIdentifier>>"
            redis_operation: "SMEMBERS {env}:roguelike:active_sessions"

          - name: count
            signature: "fn count(&self) -> AsyncIO<u64>"
            redis_operation: "SCARD {env}:roguelike:active_sessions"

    # -------------------------------------------------------------------------
    # Leaderboard
    # -------------------------------------------------------------------------
    - name: Leaderboard
      description: スコアランキング
      key_patterns:
        global: "{env}:roguelike:leaderboard:global"
        daily: "{env}:roguelike:leaderboard:daily:{YYYYMMDD}"
      data_structure: Sorted Set
      ttl:
        global: none
        daily: 604800  # 7 days
      serialization:
        score: f64
        member: JSON string

      member_structure:
        fields:
          - name: player_name
            type: String
          - name: game_id
            type: String
          - name: dungeon_depth
            type: u32
          - name: outcome
            type: String

      port_interface:
        trait_name: Leaderboard
        methods:
          - name: add_score
            signature: "fn add_score(&self, entry: &LeaderboardEntry) -> AsyncIO<()>"
            redis_operation: "ZADD {key} {score} {member_json}"

          - name: get_top
            signature: "fn get_top(&self, count: usize) -> AsyncIO<Vec<LeaderboardEntry>>"
            redis_operation: "ZREVRANGE {key} 0 {count-1} WITHSCORES"

          - name: get_rank
            signature: "fn get_rank(&self, game_id: &GameIdentifier) -> AsyncIO<Option<u64>>"
            redis_operation: "ZREVRANK {key} {member}"

    # -------------------------------------------------------------------------
    # Rate Limiter
    # -------------------------------------------------------------------------
    - name: RateLimiter
      description: API レート制限
      key_pattern: "{env}:roguelike:ratelimit:{player_id}:{endpoint}"
      data_structure: "String (counter)"
      ttl: 60  # 1 minute
      serialization: "none (integer)"

      port_interface:
        trait_name: RateLimiter
        methods:
          - name: increment
            signature: "fn increment(&self, player_id: &str, endpoint: &str) -> AsyncIO<u64>"
            redis_operation: "INCR {key}"

          - name: check_limit
            signature: "fn check_limit(&self, player_id: &str, endpoint: &str, limit: u64) -> AsyncIO<bool>"

  # ---------------------------------------------------------------------------
  # Adapter Implementation Structure
  # ---------------------------------------------------------------------------
  adapter_structure:
    directory: "src/infrastructure/redis/"
    files:
      - name: mod.rs
        description: モジュール定義

      - name: connection.rs
        description: Redis 接続プール管理

      - name: serialization.rs
        description: bincode/JSON シリアライズ切替

      - name: session_cache.rs
        description: SessionCache adapter 実装

      - name: turn_lock.rs
        description: TurnLock adapter 実装（Lua scripts）

      - name: temp_cache.rs
        description: TemporaryDataCache adapter 実装

      - name: active_sessions.rs
        description: ActiveSessionRegistry adapter 実装

      - name: leaderboard.rs
        description: Leaderboard adapter 実装

      - name: rate_limiter.rs
        description: RateLimiter adapter 実装

# =============================================================================
# lambars Usage in Infrastructure Layer
# =============================================================================

lambars_usage:
  overview: |
    インフラストラクチャ層では lambars の以下の機能を活用する：
    - AsyncIO: 全ての DB/Redis 操作を純粋な値として表現
    - bracket: リソース（接続プール）の安全な取得・解放
    - pipe!/compose!: クエリ結果の変換パイプライン
    - PersistentVector/PersistentHashMap: ドメインオブジェクトのシリアライズ/デシリアライズ
    - Either: エラーハンドリング
    - Traversable: バッチ操作の合成

  features:
    # -------------------------------------------------------------------------
    # AsyncIO - 副作用の明示的な管理
    # -------------------------------------------------------------------------
    - name: AsyncIO
      description: |
        全ての DB/Redis 操作は AsyncIO でラップされ、副作用が型レベルで追跡される。
        これにより、IO 操作の合成が可能になり、実行タイミングを制御できる。
      usage_locations:
        - MySQL Repository の全メソッド
        - Redis Cache の全メソッド
        - EventStore の全メソッド
        - SnapshotStore の全メソッド

      code_example: |
        // GameSessionRepository の実装例
        impl GameSessionRepository for MySqlGameSessionRepository {
            fn find_by_id(&self, id: &GameIdentifier) -> AsyncIO<Option<GameSession>> {
                let pool = self.pool.clone();
                let id = id.clone();

                AsyncIO::new(async move {
                    let row = sqlx::query_as::<_, GameSessionRow>(
                        "SELECT * FROM game_sessions WHERE game_id = ?"
                    )
                    .bind(id.as_bytes())
                    .fetch_optional(&pool)
                    .await?;

                    Ok(row.map(GameSession::from))
                })
            }

            fn save(&self, session: &GameSession) -> AsyncIO<()> {
                let pool = self.pool.clone();
                let session = session.clone();

                AsyncIO::new(async move {
                    sqlx::query(
                        "INSERT INTO game_sessions (...) VALUES (...) ON DUPLICATE KEY UPDATE ..."
                    )
                    .bind(...)
                    .execute(&pool)
                    .await?;

                    Ok(())
                })
            }
        }

    # -------------------------------------------------------------------------
    # bracket - リソース安全な接続管理
    # -------------------------------------------------------------------------
    - name: bracket
      description: |
        AsyncIO::bracket を使用して、DB 接続やトランザクションの
        安全な取得・解放を保証する。エラー発生時も確実にリソースが解放される。
      usage_locations:
        - トランザクション管理
        - 接続プールからの接続取得
        - 分散ロックの取得・解放

      code_example: |
        // トランザクションでの bracket 使用例
        fn save_with_events(
            &self,
            session: &GameSession,
            events: &[GameEvent],
        ) -> AsyncIO<()> {
            let pool = self.pool.clone();
            let session = session.clone();
            let events = events.to_vec();

            // bracket パターン: acquire -> use -> release
            AsyncIO::bracket(
                // acquire: トランザクション開始
                AsyncIO::new(async move {
                    pool.begin().await.map_err(InfraError::from)
                }),
                // release: コミットまたはロールバック
                |tx, result| AsyncIO::new(async move {
                    match result {
                        Ok(_) => tx.commit().await.map_err(InfraError::from),
                        Err(_) => tx.rollback().await.map_err(InfraError::from),
                    }
                }),
                // use: トランザクション内の操作
                |tx| AsyncIO::new(async move {
                    // セッション保存
                    sqlx::query("INSERT INTO game_sessions ...")
                        .execute(&mut *tx)
                        .await?;

                    // イベント保存
                    for event in events {
                        sqlx::query("INSERT INTO game_events ...")
                            .execute(&mut *tx)
                            .await?;
                    }

                    Ok(())
                })
            )
        }

        // 分散ロックでの bracket 使用例
        fn with_turn_lock<A>(
            &self,
            game_id: &GameIdentifier,
            action: AsyncIO<A>,
        ) -> AsyncIO<A> {
            AsyncIO::bracket(
                // acquire: ロック取得
                self.turn_lock.acquire(game_id, Duration::from_secs(30)),
                // release: ロック解放
                |lock_id, _| self.turn_lock.release(game_id, &lock_id),
                // use: ロック内の操作
                |_| action
            )
        }

    # -------------------------------------------------------------------------
    # pipe!/compose! - クエリ結果の変換
    # -------------------------------------------------------------------------
    - name: "pipe!/compose!"
      description: |
        DB から取得した生データをドメインオブジェクトに変換する際、
        pipe! マクロで変換パイプラインを構築する。
      usage_locations:
        - Row → Entity 変換
        - JSON → 永続データ構造変換
        - 複数テーブル結合結果の組み立て

      code_example: |
        // Row からドメインオブジェクトへの変換パイプライン
        impl From<GameSessionRow> for GameSession {
            fn from(row: GameSessionRow) -> Self {
                pipe!(
                    row,
                    |r| GameIdentifier::from_bytes(&r.game_id),
                    |id| {
                        let status = pipe!(
                            r.status.as_str(),
                            |s| match s {
                                "in_progress" => GameStatus::InProgress,
                                "victory" => GameStatus::Victory,
                                "defeat" => GameStatus::Defeat,
                                "paused" => GameStatus::Paused,
                                _ => GameStatus::InProgress,
                            }
                        );
                        (id, status)
                    },
                    |(id, status)| GameSession {
                        identifier: id,
                        turn_count: TurnCount::new(r.turn_count),
                        status,
                        seed: RandomSeed::new(r.random_seed),
                        event_sequence: r.event_sequence,
                        // ... 他のフィールドも同様に変換
                    }
                )
            }
        }

        // 複数クエリ結果の合成
        fn load_full_session(&self, id: &GameIdentifier) -> AsyncIO<Option<GameSession>> {
            pipe!(
                self.find_session_row(id),
                |session_io| session_io.flat_map(|opt_row| {
                    match opt_row {
                        Some(row) => pipe!(
                            AsyncIO::pure(row),
                            |row_io| row_io.flat_map(|r| {
                                // 関連データを並列取得
                                let player_io = self.load_player(&r.player_id);
                                let floor_io = self.load_floor(&r.game_id, r.current_floor_level);
                                let enemies_io = self.load_enemies(&r.game_id, r.current_floor_level);

                                // 全て合成
                                player_io.flat_map(move |player| {
                                    floor_io.flat_map(move |floor| {
                                        enemies_io.map(move |enemies| {
                                            Some(GameSession::assemble(r, player, floor, enemies))
                                        })
                                    })
                                })
                            })
                        ),
                        None => AsyncIO::pure(None),
                    }
                })
            )
        }

    # -------------------------------------------------------------------------
    # PersistentVector/PersistentHashMap - シリアライズ
    # -------------------------------------------------------------------------
    - name: Persistent Data Structures
      description: |
        ドメインで使用する永続データ構造（PersistentVector, PersistentHashMap 等）を
        JSON/bincode にシリアライズ/デシリアライズする。
        serde の Serialize/Deserialize を活用。
      usage_locations:
        - MySQL JSON カラムへの保存
        - Redis bincode シリアライズ
        - スナップショット保存

      code_example: |
        // PersistentVector のシリアライズ実装
        // lambars の PersistentVector は serde を実装済み

        // Inventory (PersistentVector<ItemStack>) の JSON 変換
        fn serialize_inventory(inventory: &Inventory) -> serde_json::Value {
            // PersistentVector は自動的に JSON 配列にシリアライズされる
            serde_json::to_value(&inventory.items).unwrap()
        }

        fn deserialize_inventory(json: serde_json::Value, capacity: u32) -> Inventory {
            let items: PersistentVector<ItemStack> = serde_json::from_value(json).unwrap();
            Inventory { items, capacity }
        }

        // Tiles (PersistentVector<PersistentVector<Tile>>) の変換
        fn serialize_tiles(tiles: &PersistentVector<PersistentVector<Tile>>) -> serde_json::Value {
            serde_json::to_value(tiles).unwrap()
        }

        // Entities (PersistentHashMap<EntityId, Entity>) の変換
        fn serialize_entities(
            entities: &PersistentHashMap<EntityIdentifier, Entity>
        ) -> serde_json::Value {
            // PersistentHashMap は JSON オブジェクトにシリアライズ
            serde_json::to_value(entities).unwrap()
        }

        // Redis bincode シリアライズ
        fn to_bincode<T: Serialize>(value: &T) -> Vec<u8> {
            bincode::serialize(value).unwrap()
        }

        fn from_bincode<T: DeserializeOwned>(bytes: &[u8]) -> T {
            bincode::deserialize(bytes).unwrap()
        }

    # -------------------------------------------------------------------------
    # Either - エラーハンドリング
    # -------------------------------------------------------------------------
    - name: Either
      description: |
        インフラ層のエラーを Either で表現し、
        ドメインエラーとインフラエラーを型安全に区別する。
      usage_locations:
        - Repository エラーハンドリング
        - 接続エラー処理
        - シリアライズエラー処理

      code_example: |
        // インフラエラー型
        pub enum InfraError {
            Database(sqlx::Error),
            Cache(redis::RedisError),
            Serialization(SerializationError),
            NotFound { entity_type: String, id: String },
        }

        // Either を使ったエラー変換
        fn find_by_id(&self, id: &GameIdentifier) -> AsyncIO<Either<InfraError, Option<GameSession>>> {
            let pool = self.pool.clone();
            let id = id.clone();

            AsyncIO::new(async move {
                match sqlx::query_as::<_, GameSessionRow>("SELECT * FROM game_sessions WHERE game_id = ?")
                    .bind(id.as_bytes())
                    .fetch_optional(&pool)
                    .await
                {
                    Ok(Some(row)) => Either::Right(Some(GameSession::from(row))),
                    Ok(None) => Either::Right(None),
                    Err(e) => Either::Left(InfraError::Database(e)),
                }
            })
        }

        // Either の合成
        fn save_and_cache(
            &self,
            session: &GameSession,
        ) -> AsyncIO<Either<InfraError, ()>> {
            pipe!(
                self.repository.save(session),
                |save_io| save_io.flat_map(|result| {
                    match result {
                        Either::Right(()) => {
                            // 保存成功 → キャッシュ更新
                            self.cache.set(&session.identifier, session, self.config.cache_ttl)
                                .map(|cache_result| cache_result)
                        }
                        Either::Left(e) => AsyncIO::pure(Either::Left(e)),
                    }
                })
            )
        }

    # -------------------------------------------------------------------------
    # Traversable - バッチ操作
    # -------------------------------------------------------------------------
    - name: Traversable
      description: |
        複数のエンティティを一括で操作する際、
        Traversable を使って AsyncIO のリストを合成する。
      usage_locations:
        - 複数敵の一括保存
        - 複数イベントの一括追加
        - バッチクエリ結果の変換

      code_example: |
        // 複数イベントの一括保存
        fn append_events(
            &self,
            game_id: &GameIdentifier,
            events: &[GameEvent],
        ) -> AsyncIO<()> {
            // Vec<GameEvent> → Vec<AsyncIO<()>> → AsyncIO<Vec<()>> → AsyncIO<()>
            let insert_ios: Vec<AsyncIO<()>> = events
                .iter()
                .enumerate()
                .map(|(seq, event)| self.insert_event(game_id, seq as u64, event))
                .collect();

            // Traversable::sequence で全ての AsyncIO を合成
            AsyncIO::sequence(insert_ios).map(|_| ())
        }

        // 複数敵の一括読み込み
        fn load_enemies(
            &self,
            game_id: &GameIdentifier,
            floor_level: u32,
        ) -> AsyncIO<PersistentVector<Enemy>> {
            let pool = self.pool.clone();

            AsyncIO::new(async move {
                let rows = sqlx::query_as::<_, EnemyRow>(
                    "SELECT * FROM enemies WHERE game_id = ? AND floor_level = ? AND is_alive = TRUE"
                )
                .bind(game_id.as_bytes())
                .bind(floor_level)
                .fetch_all(&pool)
                .await?;

                // Vec<EnemyRow> を PersistentVector<Enemy> に変換
                Ok(rows.into_iter().map(Enemy::from).collect())
            })
        }

    # -------------------------------------------------------------------------
    # Foldable - 集計クエリ結果の処理
    # -------------------------------------------------------------------------
    - name: Foldable
      description: |
        クエリ結果の集計や変換に Foldable を使用。
        Event Sourcing での状態再構築にも活用。
      usage_locations:
        - イベントからの状態再構築
        - 統計情報の集計
        - リーダーボードスコア計算

      code_example: |
        // Event Sourcing: イベントからの状態再構築
        fn reconstruct_from_events(
            &self,
            game_id: &GameIdentifier,
            base_state: Option<GameSession>,
            since_sequence: u64,
        ) -> AsyncIO<GameSession> {
            pipe!(
                self.load_events_since(game_id, since_sequence),
                |events_io| events_io.map(|events| {
                    let initial = base_state.unwrap_or_else(GameSession::empty);

                    // Foldable::fold_left でイベントを順次適用
                    events.fold_left(initial, |state, event| {
                        state.apply_event(&event)
                    })
                })
            )
        }

        // スコア計算
        fn calculate_final_score(session: &GameSession) -> u64 {
            // 複数の要素を fold で集計
            let base_score = session.turn_count.value() * 10;

            let enemy_score = session.defeated_enemies
                .fold_left(0u64, |acc, enemy| {
                    acc + enemy.score_value()
                });

            let depth_bonus = session.max_floor_reached * 1000;

            base_score + enemy_score + depth_bonus
        }

  # ---------------------------------------------------------------------------
  # Implementation Examples
  # ---------------------------------------------------------------------------
  implementation_examples:
    mysql_repository: |
      // MySQL Repository の完全な実装例
      pub struct MySqlGameSessionRepository {
          pool: MySqlPool,
      }

      impl MySqlGameSessionRepository {
          pub fn new(pool: MySqlPool) -> Self {
              Self { pool }
          }
      }

      impl GameSessionRepository for MySqlGameSessionRepository {
          fn find_by_id(&self, id: &GameIdentifier) -> AsyncIO<Option<GameSession>> {
              let pool = self.pool.clone();
              let id_bytes = id.as_bytes().to_vec();

              AsyncIO::new(async move {
                  // メインクエリ
                  let session_row = sqlx::query_as::<_, GameSessionRow>(
                      "SELECT * FROM game_sessions WHERE game_id = ?"
                  )
                  .bind(&id_bytes)
                  .fetch_optional(&pool)
                  .await?;

                  match session_row {
                      Some(row) => {
                          // 関連データを取得
                          let player = sqlx::query_as::<_, PlayerRow>(
                              "SELECT * FROM players WHERE player_id = ?"
                          )
                          .bind(&row.player_id)
                          .fetch_one(&pool)
                          .await?;

                          let floor = sqlx::query_as::<_, FloorRow>(
                              "SELECT * FROM floors WHERE game_id = ? AND level = ?"
                          )
                          .bind(&id_bytes)
                          .bind(row.current_floor_level)
                          .fetch_one(&pool)
                          .await?;

                          let enemies = sqlx::query_as::<_, EnemyRow>(
                              "SELECT * FROM enemies WHERE game_id = ? AND floor_level = ? AND is_alive = TRUE"
                          )
                          .bind(&id_bytes)
                          .bind(row.current_floor_level)
                          .fetch_all(&pool)
                          .await?;

                          // pipe! で組み立て
                          Ok(Some(pipe!(
                              (row, player, floor, enemies),
                              |(r, p, f, e)| GameSession::assemble(
                                  GameSessionData::from(r),
                                  Player::from(p),
                                  Floor::from(f),
                                  e.into_iter().map(Enemy::from).collect()
                              )
                          )))
                      }
                      None => Ok(None),
                  }
              })
          }

          fn save(&self, session: &GameSession) -> AsyncIO<()> {
              let pool = self.pool.clone();
              let session = session.clone();

              AsyncIO::bracket(
                  // トランザクション開始
                  AsyncIO::new({
                      let pool = pool.clone();
                      async move { pool.begin().await.map_err(InfraError::from) }
                  }),
                  // コミット/ロールバック
                  |mut tx, result| AsyncIO::new(async move {
                      match result {
                          Ok(_) => tx.commit().await.map_err(InfraError::from),
                          Err(e) => {
                              let _ = tx.rollback().await;
                              Err(e)
                          }
                      }
                  }),
                  // トランザクション内操作
                  |mut tx| AsyncIO::new(async move {
                      // game_sessions UPSERT
                      sqlx::query(r#"
                          INSERT INTO game_sessions (game_id, player_id, current_floor_level, turn_count, status, random_seed, event_sequence)
                          VALUES (?, ?, ?, ?, ?, ?, ?)
                          ON DUPLICATE KEY UPDATE
                              current_floor_level = VALUES(current_floor_level),
                              turn_count = VALUES(turn_count),
                              status = VALUES(status),
                              event_sequence = VALUES(event_sequence)
                      "#)
                      .bind(session.identifier.as_bytes())
                      .bind(session.player.identifier.as_bytes())
                      .bind(session.current_floor.level.value())
                      .bind(session.turn_count.value())
                      .bind(session.status.as_str())
                      .bind(session.seed.value())
                      .bind(session.event_sequence)
                      .execute(&mut *tx)
                      .await?;

                      // players UPSERT
                      sqlx::query(r#"
                          INSERT INTO players (player_id, game_id, name, position_x, position_y, ...)
                          VALUES (?, ?, ?, ?, ?, ...)
                          ON DUPLICATE KEY UPDATE ...
                      "#)
                      .bind(...)
                      .execute(&mut *tx)
                      .await?;

                      // floors UPSERT
                      // enemies UPSERT
                      // ...

                      Ok(())
                  })
              )
          }
      }

    redis_cache: |
      // Redis Cache の実装例
      pub struct RedisSessionCache {
          client: redis::Client,
          config: CacheConfig,
      }

      impl SessionCache for RedisSessionCache {
          fn get(&self, game_id: &GameIdentifier) -> AsyncIO<Option<GameSession>> {
              let client = self.client.clone();
              let key = format!("{}:roguelike:session:{}", self.config.env, game_id);

              AsyncIO::new(async move {
                  let mut conn = client.get_async_connection().await?;
                  let bytes: Option<Vec<u8>> = redis::cmd("GET")
                      .arg(&key)
                      .query_async(&mut conn)
                      .await?;

                  Ok(bytes.map(|b| from_bincode(&b)))
              })
          }

          fn set(
              &self,
              game_id: &GameIdentifier,
              session: &GameSession,
              ttl: Duration,
          ) -> AsyncIO<()> {
              let client = self.client.clone();
              let key = format!("{}:roguelike:session:{}", self.config.env, game_id);
              let bytes = to_bincode(session);
              let ttl_secs = ttl.as_secs() as usize;

              AsyncIO::new(async move {
                  let mut conn = client.get_async_connection().await?;
                  redis::cmd("SET")
                      .arg(&key)
                      .arg(bytes)
                      .arg("EX")
                      .arg(ttl_secs)
                      .query_async(&mut conn)
                      .await?;

                  Ok(())
              })
          }

          fn invalidate(&self, game_id: &GameIdentifier) -> AsyncIO<()> {
              let client = self.client.clone();
              let key = format!("{}:roguelike:session:{}", self.config.env, game_id);

              AsyncIO::new(async move {
                  let mut conn = client.get_async_connection().await?;
                  redis::cmd("DEL")
                      .arg(&key)
                      .query_async(&mut conn)
                      .await?;

                  Ok(())
              })
          }
      }
