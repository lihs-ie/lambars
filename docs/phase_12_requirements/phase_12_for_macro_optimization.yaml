# Phase 12: for_! / for_async! マクロ最適化 - 要件定義
# for_! マクロのパフォーマンスを改善し、手書き flat_map と同等の性能を達成する

version: "1.0.0"
created_at: "2026-01-03"
phase_id: phase_12
phase_name: for_! / for_async! マクロ最適化
phase_name_en: for_! / for_async! Macro Optimization

# =============================================================================
# 概要（Overview）
# =============================================================================

overview:
  description: |
    `for_!` マクロのパフォーマンスを改善し、手書きの flat_map チェーンと
    同等の性能を達成する。現状のベンチマーク結果では、for_! マクロは
    手書きコードと比較して 4〜37 倍遅い状況にある。

    また、`for_async!` マクロについては、AsyncIO::pure() の使用による
    パフォーマンスオーバーヘッドを文書化し、適切な使用方法をガイドする。

  current_performance:
    for_single_iteration:
      for_macro: "~155 µs (10,000 elements)"
      hand_written_map: "~4 µs (10,000 elements)"
      ratio: "~37x slower"

    for_nested_two_levels:
      for_macro: "~360 µs (100x100 = 10,000 iterations)"
      hand_written_flat_map: "~51 µs (10,000 iterations)"
      ratio: "~7x slower"

    for_nested_three_levels:
      for_macro: "~4 ms (20x20x20 = 8,000 iterations)"
      hand_written_flat_map: "~800 µs (8,000 iterations)"
      ratio: "~5x slower"

  target_performance:
    for_single_iteration: "1.5x 以内"
    for_nested_two_levels: "2x 以内"
    for_nested_three_levels: "2x 以内"

  goals:
    - for_! マクロを手書き flat_map と同等のパフォーマンスに改善する
    - 中間 Vec アロケーションを排除しイテレータベースの展開に変更する
    - 単一イテレーションでは map を使用して最適化する
    - for_async! マクロのパフォーマンスガイダンスをドキュメント化する

  non_goals:
    - for_async! マクロのマクロレベル最適化（複雑すぎるため）
    - AsyncIO 自体のパフォーマンス改善（別フェーズで対応）
    - ガード条件（if 句）のサポート（将来の拡張）

  functional_programming_principles:
    zero_cost_abstraction: |
      関数型の抽象は手書きコードと同等のパフォーマンスであるべき。
      for_! マクロは flat_map チェーンの糖衣構文であり、
      追加のオーバーヘッドを持つべきではない。

    lazy_evaluation: |
      イテレータベースの展開により、必要になるまで計算を遅延させる。
      中間 Vec の即時生成ではなく、イテレータのチェーンで計算を表現する。

# =============================================================================
# ボトルネック分析（Bottleneck Analysis）
# =============================================================================

bottleneck_analysis:
  for_macro:
    - id: BN-001
      name: yield での vec! アロケーション
      severity: critical
      description: |
        現在の実装では、yield で `vec![$result]` を生成している。
        これは各要素ごとにヒープアロケーションを発生させる。

      current_code: |
        (yield $result:expr) => {
            vec![$result]
        };

      impact: |
        N 個の要素に対して N 回のヒープアロケーションが発生。
        単一イテレーションで 21-37x のオーバーヘッド。

      solution: |
        `std::iter::once($result)` を使用してアロケーションを回避。

    - id: BN-002
      name: 中間 .collect() の累積
      severity: high
      description: |
        各ネストレベルで `.collect::<Vec<_>>()` が呼ばれ、
        中間 Vec が生成される。

      current_code: |
        ($pattern:pat <= $collection:expr ; $($rest:tt)+) => {
            $collection.into_iter()
                .flat_map(|$pattern| {
                    $crate::for_!($($rest)+)  // Vec を返す
                })
                .collect::<Vec<_>>()          // 各レベルで collect
        };

      impact: |
        2 段ネストで 2 回の collect、3 段で 3 回の collect。
        4-7x のオーバーヘッド。

      solution: |
        内部ルール `@iter` を導入し、中間はイテレータを返す。
        最外層の `@collect` でのみ collect を行う。

    - id: BN-003
      name: 単一イテレーションでの flat_map 使用
      severity: medium
      description: |
        単一イテレーションでも flat_map を使用しているが、
        map で十分なケースでは map を使用すべき。

      impact: |
        flat_map は map より若干オーバーヘッドがある。

      solution: |
        `pattern <= collection ; yield result` パターンを検出し、
        map に特殊化する。

  for_async_macro:
    - id: BN-004
      name: AsyncIO 二重ボクシング
      severity: high
      description: |
        AsyncIO は `Box<dyn FnOnce()>` + `Pin<Box<dyn Future>>` の
        二重ボクシングを行っており、各操作でオーバーヘッドが発生する。

      impact: |
        AsyncIO::pure() を使用すると、純粋な値でもボクシングが発生。
        約 30x のオーバーヘッド。

      solution: |
        マクロレベルでの最適化は複雑すぎるため、
        ドキュメントで `let` の使用を推奨する。

# =============================================================================
# 機能要件（Functional Requirements）
# =============================================================================

functional_requirements:
  - id: FR-001
    name: "@iter 内部ルールの導入"
    priority: critical
    description: |
      マクロ内部でイテレータを返すルールを導入し、
      中間 collect を排除する。

    location: src/compose/for_macro.rs

    design: |
      ```rust
      // エントリーポイント: 最外層で @collect を呼ぶ
      ($pattern:pat <= $collection:expr ; $($rest:tt)+) => {
          $crate::for_!(@collect $pattern <= $collection ; $($rest)+)
      };

      // @collect: 最外層でのみ collect を行う
      (@collect $pattern:pat <= $collection:expr ; $($rest:tt)+) => {{
          $collection.into_iter().flat_map(|$pattern| {
              $crate::for_!(@iter $($rest)+)
          }).collect::<Vec<_>>()
      }};

      // @iter: 中間レベルではイテレータを返す
      (@iter $pattern:pat <= $collection:expr ; $($rest:tt)+) => {{
          $collection.into_iter().flat_map(|$pattern| {
              $crate::for_!(@iter $($rest)+)
          })
      }};

      // @iter yield: once() を使用
      (@iter yield $result:expr) => {
          std::iter::once($result)
      };
      ```

    acceptance_criteria:
      - 既存の全テストがパスすること
      - 中間 Vec アロケーションが発生しないこと
      - ネストしたイテレーションで 2x 以内のオーバーヘッドになること

  - id: FR-002
    name: 単一イテレーションの map 特殊化
    priority: high
    description: |
      `pattern <= collection ; yield result` パターンを検出し、
      flat_map ではなく map を使用する。

    location: src/compose/for_macro.rs

    design: |
      ```rust
      // 単一イテレーション: map を使用
      (@collect $pattern:pat <= $collection:expr ; yield $result:expr) => {{
          $collection.into_iter().map(|$pattern| $result).collect::<Vec<_>>()
      }};
      ```

    acceptance_criteria:
      - 単一イテレーションで 1.5x 以内のオーバーヘッドになること
      - 既存の単一イテレーションテストがパスすること

  - id: FR-003
    name: let バインディングの @iter 対応
    priority: high
    description: |
      let バインディングを @iter ルールに対応させる。

    location: src/compose/for_macro.rs

    design: |
      ```rust
      // @iter let: let 後の継続をイテレータとして返す
      (@iter let $pattern:pat = $value:expr ; $($rest:tt)+) => {{
          let $pattern = $value;
          $crate::for_!(@iter $($rest)+)
      }};

      // @collect let: 同様
      (@collect let $pattern:pat = $value:expr ; $($rest:tt)+) => {{
          let $pattern = $value;
          $crate::for_!(@collect $($rest)+)
      }};
      ```

    acceptance_criteria:
      - let バインディングを含むテストがパスすること

  - id: FR-004
    name: for_async! ドキュメント改善
    priority: medium
    description: |
      for_async! マクロのパフォーマンスガイダンスを追加し、
      `let` と `AsyncIO::pure()` の使い分けを明確にする。

    location: src/compose/for_async_macro.rs

    documentation: |
      ```rust
      /// # Performance Tips
      ///
      /// ## Prefer `let` over `AsyncIO::pure()` for pure computations
      ///
      /// Pure computations should use `let` bindings instead of
      /// `AsyncIO::pure()` to avoid boxing overhead:
      ///
      /// ```rust,ignore
      /// // Recommended: Use let for pure computations
      /// for_async! {
      ///     x <= items;
      ///     let doubled = x * 2;  // No overhead
      ///     yield doubled
      /// }
      ///
      /// // Not recommended: AsyncIO::pure() adds boxing overhead
      /// for_async! {
      ///     x <= items;
      ///     doubled <~ AsyncIO::pure(x * 2);  // ~30x overhead per bind
      ///     yield doubled
      /// }
      /// ```
      ///
      /// Use `<~` only for actual async operations:
      ///
      /// ```rust,ignore
      /// for_async! {
      ///     x <= items;
      ///     result <~ fetch_async(x);  // Actual async operation
      ///     yield result
      /// }
      /// ```
      ```

    acceptance_criteria:
      - ドキュメントが追加されていること
      - cargo doc が成功すること

# =============================================================================
# 非機能要件（Non-Functional Requirements）
# =============================================================================

non_functional_requirements:
  - id: NFR-001
    name: 後方互換性
    priority: critical
    description: |
      既存の for_! マクロを使用するコードが変更なしで動作すること。

    acceptance_criteria:
      - 全ての既存テストがパスすること
      - tests/for_macro_tests.rs が全てパスすること
      - tests/for_macro_laws.rs が全てパスすること
      - tests/for_macro_integration.rs が全てパスすること

  - id: NFR-002
    name: パフォーマンス目標
    priority: critical
    description: |
      ベンチマークで目標パフォーマンスを達成すること。

    acceptance_criteria:
      - for_single_iteration: 手書き map の 1.5x 以内
      - for_nested_two_levels: 手書き flat_map の 2x 以内
      - for_nested_three_levels: 手書き flat_map の 2x 以内

  - id: NFR-003
    name: コード品質
    priority: high
    description: |
      Clippy の警告がなく、unsafe コードを使用しないこと。

    acceptance_criteria:
      - cargo clippy --all-features -- -D warnings がパスすること
      - unsafe コードを使用しないこと

# =============================================================================
# テスト戦略（Test Strategy）
# =============================================================================

test_strategy:
  unit_tests:
    - name: 既存テストの回帰確認
      file: tests/for_macro_tests.rs
      description: 既存の全テストケースがパスすることを確認

    - name: 法則テストの回帰確認
      file: tests/for_macro_laws.rs
      description: Monad 法則テストがパスすることを確認

    - name: 統合テストの回帰確認
      file: tests/for_macro_integration.rs
      description: 永続データ構造との統合テストがパスすることを確認

  benchmark_tests:
    - name: 単一イテレーションベンチマーク
      file: benches/for_macro_bench.rs
      function: benchmark_single_iteration
      target: "1.5x 以内"

    - name: 2段ネストベンチマーク
      file: benches/for_macro_bench.rs
      function: benchmark_nested_two_levels
      target: "2x 以内"

    - name: 3段ネストベンチマーク
      file: benches/for_macro_bench.rs
      function: benchmark_nested_three_levels
      target: "2x 以内"

# =============================================================================
# 修正対象ファイル（Files to Modify）
# =============================================================================

files_to_modify:
  - path: src/compose/for_macro.rs
    changes:
      - "@iter 内部ルールの追加"
      - "@collect 内部ルールの追加"
      - "単一イテレーションの map 特殊化"
      - "let バインディングの @iter 対応"

  - path: src/compose/for_async_macro.rs
    changes:
      - "パフォーマンスガイダンスのドキュメント追加"

# =============================================================================
# リスクと緩和策（Risks and Mitigations）
# =============================================================================

risks:
  - id: RISK-001
    name: 型推論への影響
    severity: medium
    description: |
      イテレータベースの展開により、型推論が失敗する可能性がある。

    mitigation: |
      全テストで回帰確認を行い、型推論の問題があれば対処する。
      必要に応じて型アノテーションを追加する。

  - id: RISK-002
    name: マクロルール順序の問題
    severity: medium
    description: |
      新しいルールの追加により、既存のルールとの優先順位が変わる可能性がある。

    mitigation: |
      各ルールに優先順位をコメントで明記する。
      より具体的なルールを先に配置する。

  - id: RISK-003
    name: 複雑なパターンマッチの対応
    severity: low
    description: |
      タプルパターンやネストしたパターンで問題が発生する可能性がある。

    mitigation: |
      既存のパターンテストで回帰確認を行う。
