# Phase 2: 関数合成ユーティリティ（Function Composition）要件定義
#
# 概要:
#   関数型プログラミングのスタイルを支援する関数合成・パイプライン・部分適用の
#   ユーティリティを提供する。これらは関数を第一級の値として扱い、
#   宣言的なコードを書くための基盤となる。
#
# 設計方針:
#   1. マクロによる構文糖衣で関数合成を簡潔に記述可能にする
#   2. 型安全性を維持しながら、可変長引数に対応する
#   3. Rust の所有権・借用システムと調和した設計
#   4. 各操作の数学的法則を明確に定義し、プロパティベーステストで検証
#
# 参照:
#   - CLAUDE.md の「3.7 「関数型記法」や合成を支える標準構文」セクション
#   - Haskell の (.) 演算子、($) 演算子
#   - Elm のパイプライン演算子 |>
#   - F# のパイプライン演算子 |>

version: "1.0.0"
phase: 2
name: "Function Composition"
description: |
  関数型プログラミングにおいて、関数は第一級の値であり、
  関数を組み合わせて新しい関数を作ることが中心的なプログラミングスタイルとなる。

  このフェーズでは、以下のユーティリティを提供する:
  - compose!: 関数を右から左へ合成する（数学的な関数合成）
  - pipe!: データを左から右へ流す（データフロースタイル）
  - partial!: 部分適用で一部の引数を固定した新しい関数を生成
  - curry!: 複数引数関数をカリー化（単一引数関数のチェーンに変換）
  - 補助関数: identity, constant, flip

# 関数合成の数学的背景
mathematical_background:
  function_composition:
    description: |
      関数合成 (composition) は、二つの関数 f: B -> C と g: A -> B から
      新しい関数 (f . g): A -> C を作る操作である。

      (f . g)(x) = f(g(x))

      これは右から左への合成であり、数学的な記法に従う。

    notation: |
      - 数学: (f . g)(x) = f(g(x))
      - Haskell: (f . g) x = f (g x)
      - Rust (本ライブラリ): compose!(f, g)(x)

  pipeline:
    description: |
      パイプラインは関数合成の「逆方向」の記法で、データの流れを
      左から右へ記述する。プログラムの実行順序と記述順序が一致するため
      読みやすいことが多い。

      x |> f |> g |> h = h(g(f(x)))

    notation: |
      - F# / Elm: x |> f |> g |> h
      - Rust (本ライブラリ): pipe!(x, f, g, h)

  partial_application:
    description: |
      部分適用 (partial application) は、複数引数の関数の一部の引数を
      固定して、より少ない引数を取る新しい関数を作る操作である。

      add(a, b) = a + b に対して
      add5 = partial(add, 5, _) とすると
      add5(3) = add(5, 3) = 8

  currying:
    description: |
      カリー化 (currying) は、複数引数の関数を単一引数関数のチェーンに
      変換する操作である。これは部分適用を可能にする基本的な変換である。

      curry(f)(a)(b)(c) = f(a, b, c)

      名前は論理学者 Haskell Curry に由来する。

requirements:
  # ============================================================================
  # 1. compose! マクロ
  # ============================================================================
  - id: compose_macro
    name: compose! マクロ
    description: |
      関数を右から左へ合成するマクロ。
      数学的な関数合成の記法に従い、compose!(f, g, h)(x) = f(g(h(x))) となる。

      右から左への合成は、型の観点からも自然である:
      - h: A -> B
      - g: B -> C
      - f: C -> D
      - compose!(f, g, h): A -> D

      合成された関数は、元の関数が全て Fn を実装していれば Fn を実装し、
      何度でも呼び出し可能である。

    laws:
      - name: Associativity（結合律）
        description: |
          関数合成は結合的である。どの順序で合成しても結果は同じ。
        equation: "compose!(f, compose!(g, h)) == compose!(compose!(f, g), h)"
        property_test: |
          fn prop_compose_associativity<A, B, C, D>(
              f: impl Fn(C) -> D + Clone,
              g: impl Fn(B) -> C + Clone,
              h: impl Fn(A) -> B + Clone,
              x: A,
          ) -> bool
          where
              A: Clone,
              D: PartialEq,
          {
              let left = compose!(f.clone(), compose!(g.clone(), h.clone()));
              let right = compose!(compose!(f, g), h);
              left(x.clone()) == right(x)
          }

      - name: Left Identity（左恒等律）
        description: |
          恒等関数を左から合成しても関数は変わらない。
        equation: "compose!(identity, f) == f"
        property_test: |
          fn prop_compose_left_identity<A, B>(
              f: impl Fn(A) -> B + Clone,
              x: A,
          ) -> bool
          where
              A: Clone,
              B: PartialEq,
          {
              let composed = compose!(identity, f.clone());
              composed(x.clone()) == f(x)
          }

      - name: Right Identity（右恒等律）
        description: |
          恒等関数を右から合成しても関数は変わらない。
        equation: "compose!(f, identity) == f"
        property_test: |
          fn prop_compose_right_identity<A, B>(
              f: impl Fn(A) -> B + Clone,
              x: A,
          ) -> bool
          where
              A: Clone,
              B: PartialEq,
          {
              let composed = compose!(f.clone(), identity);
              composed(x.clone()) == f(x)
          }

    syntax:
      - description: 単一関数（恒等的な合成）
        example: "compose!(f)"
        result: "f と同等の関数"

      - description: 二つの関数の合成
        example: "compose!(f, g)"
        result: "|x| f(g(x))"

      - description: 三つ以上の関数の合成
        example: "compose!(f, g, h)"
        result: "|x| f(g(h(x)))"

      - description: 合成した関数の即時適用
        example: "compose!(f, g, h)(x)"
        result: "f(g(h(x)))"

    trait_bounds:
      description: |
        合成された関数の Fn トレイト境界は、元の関数のトレイト境界に依存する:
        - 全ての関数が Fn を実装: 合成も Fn を実装
        - いずれかが FnMut のみ: 合成は FnMut を実装
        - いずれかが FnOnce のみ: 合成は FnOnce を実装

        本実装では、合成された関数は Fn を実装することを要求する。
        これにより、合成された関数を何度でも呼び出せる。

      signature: |
        // 二つの関数の合成の型シグネチャ
        fn compose<A, B, C, F, G>(f: F, g: G) -> impl Fn(A) -> C
        where
            F: Fn(B) -> C,
            G: Fn(A) -> B,

    examples:
      - description: 基本的な関数合成
        code: |
          fn add_one(x: i32) -> i32 { x + 1 }
          fn double(x: i32) -> i32 { x * 2 }
          fn square(x: i32) -> i32 { x * x }

          // compose!(f, g, h)(x) = f(g(h(x)))
          let composed = compose!(add_one, double, square);
          assert_eq!(composed(3), 19); // add_one(double(square(3))) = add_one(double(9)) = add_one(18) = 19

      - description: 文字列処理の合成
        code: |
          fn to_uppercase(s: String) -> String { s.to_uppercase() }
          fn add_exclamation(s: String) -> String { format!("{}!", s) }
          fn trim_and_own(s: &str) -> String { s.trim().to_string() }

          // 注意: 最初の関数は &str を受け取るが、残りは String を受け取る
          // この場合、型推論により適切に処理される
          let process = compose!(add_exclamation, to_uppercase);
          assert_eq!(process("hello".to_string()), "HELLO!");

      - description: クロージャとの組み合わせ
        code: |
          let multiplier = 3;
          let multiply = |x: i32| x * multiplier;
          let add_ten = |x: i32| x + 10;

          let composed = compose!(add_ten, multiply);
          assert_eq!(composed(5), 25); // add_ten(multiply(5)) = add_ten(15) = 25

    dependencies: []

  # ============================================================================
  # 2. pipe! マクロ
  # ============================================================================
  - id: pipe_macro
    name: pipe! マクロ
    description: |
      データを左から右へパイプラインで流すマクロ。
      pipe!(x, f, g, h) = h(g(f(x))) となり、compose との等価性がある:

      pipe!(x, f, g, h) == compose!(h, g, f)(x)

      パイプラインは、データの変換過程を読み取る順序で記述できるため、
      複雑な変換処理の可読性を向上させる。

      各関数は FnOnce を実装していればよく、所有権を消費する関数も使用可能。

    laws:
      - name: Equivalence with compose（compose との等価性）
        description: |
          pipe は compose の逆順適用と等価である。
        equation: "pipe!(x, f, g, h) == compose!(h, g, f)(x)"
        property_test: |
          fn prop_pipe_compose_equivalence<A, B, C, D>(
              x: A,
              f: impl Fn(A) -> B + Clone,
              g: impl Fn(B) -> C + Clone,
              h: impl Fn(C) -> D + Clone,
          ) -> bool
          where
              A: Clone,
              D: PartialEq,
          {
              let pipe_result = pipe!(x.clone(), f.clone(), g.clone(), h.clone());
              let compose_result = compose!(h, g, f)(x);
              pipe_result == compose_result
          }

      - name: Left Identity（左恒等律）
        description: |
          恒等関数から始めても値は変わらない。
        equation: "pipe!(x, identity) == x"
        property_test: |
          fn prop_pipe_identity<A>(x: A) -> bool
          where
              A: Clone + PartialEq,
          {
              pipe!(x.clone(), identity) == x
          }

      - name: Associativity（結合律的な性質）
        description: |
          パイプラインは段階的に評価しても結果は同じ。
        equation: "pipe!(pipe!(x, f), g) == pipe!(x, f, g)"
        property_test: |
          fn prop_pipe_associativity<A, B, C>(
              x: A,
              f: impl Fn(A) -> B + Clone,
              g: impl Fn(B) -> C + Clone,
          ) -> bool
          where
              A: Clone,
              C: PartialEq,
          {
              let step_by_step = pipe!(pipe!(x.clone(), f.clone()), g.clone());
              let all_at_once = pipe!(x, f, g);
              step_by_step == all_at_once
          }

    syntax:
      - description: 値のみ（恒等的なパイプ）
        example: "pipe!(x)"
        result: "x"

      - description: 単一関数の適用
        example: "pipe!(x, f)"
        result: "f(x)"

      - description: 複数関数のパイプライン
        example: "pipe!(x, f, g, h)"
        result: "h(g(f(x)))"

    trait_bounds:
      description: |
        パイプラインでは、各関数は FnOnce を実装していればよい。
        これは各関数が一度だけ呼び出されるためである。

        所有権を消費する関数（FnOnce）も使用可能で、
        これによりリソースの移動を伴う変換も自然に記述できる。

      signature: |
        // pipe! の各ステップは FnOnce で十分
        // (実際にはマクロで展開されるため、明示的なシグネチャはない)

    examples:
      - description: 基本的なパイプライン
        code: |
          fn add_one(x: i32) -> i32 { x + 1 }
          fn double(x: i32) -> i32 { x * 2 }
          fn square(x: i32) -> i32 { x * x }

          // pipe!(x, f, g, h) = h(g(f(x)))
          let result = pipe!(3, square, double, add_one);
          assert_eq!(result, 19); // add_one(double(square(3))) = 19

      - description: 文字列処理のパイプライン
        code: |
          let result = pipe!(
              "  hello world  ",
              |s: &str| s.trim(),
              |s: &str| s.to_uppercase(),
              |s: String| format!("{}!", s)
          );
          assert_eq!(result, "HELLO WORLD!");

      - description: Option を通したパイプライン
        code: |
          use functional_rusty::prelude::*;

          fn parse_int(s: &str) -> Option<i32> {
              s.parse().ok()
          }

          fn double_if_positive(n: i32) -> Option<i32> {
              if n > 0 { Some(n * 2) } else { None }
          }

          // pipe! と flat_map の組み合わせ
          let result = pipe!(
              Some("42"),
              |opt| opt.flat_map(parse_int),
              |opt| opt.flat_map(double_if_positive)
          );
          assert_eq!(result, Some(84));

      - description: 所有権を消費する関数のパイプライン
        code: |
          fn consume_and_double(v: Vec<i32>) -> Vec<i32> {
              v.into_iter().map(|x| x * 2).collect()
          }

          fn consume_and_filter(v: Vec<i32>) -> Vec<i32> {
              v.into_iter().filter(|x| *x > 5).collect()
          }

          let result = pipe!(
              vec![1, 2, 3, 4, 5],
              consume_and_double,  // Vec を消費
              consume_and_filter   // Vec を消費
          );
          assert_eq!(result, vec![6, 8, 10]);

    dependencies: []

  # ============================================================================
  # 3. partial! マクロ
  # ============================================================================
  - id: partial_macro
    name: partial! マクロ
    description: |
      部分適用マクロ。複数引数関数の一部の引数を固定して、
      残りの引数を取る新しい関数を生成する。

      プレースホルダー `__`（ダブルアンダースコア）を使用して、どの引数を残すかを指定する。
      固定する引数は左から順に指定し、`__` の位置が残る引数となる。

      最大6引数までの関数に対応する。

      NOTE: Rust の macro_rules! では `_` をリテラルとしてマッチできないため、
      専用のマーカー定数 `__` を使用する。これは `functional_rusty::compose::__` として
      エクスポートされる。

    syntax:
      - description: 2引数関数の最初の引数を固定
        example: "partial!(add, 5, __)"
        result: "|b| add(5, b)"

      - description: 2引数関数の2番目の引数を固定
        example: "partial!(divide, __, 2)"
        result: "|a| divide(a, 2)"

      - description: 3引数関数の最初の引数を固定
        example: "partial!(f, x, __, __)"
        result: "|a, b| f(x, a, b)"

      - description: 3引数関数の中央の引数を固定
        example: "partial!(f, __, y, __)"
        result: "|a, c| f(a, y, c)"

      - description: 複数の引数を固定
        example: "partial!(f, x, __, z)"
        result: "|b| f(x, b, z)"

    trait_bounds:
      description: |
        部分適用では、固定する値は Clone を実装している必要がある。
        これは生成された関数が複数回呼び出される可能性があるためである。

        元の関数は Fn を実装している必要がある。

      requirements:
        - "固定する値: Clone を実装"
        - "元の関数: Fn を実装"

    max_arguments: 6

    supported_patterns:
      description: |
        サポートするプレースホルダーパターン:

        2引数:
          - partial!(f, a, __)     -> |b| f(a, b)
          - partial!(f, __, b)     -> |a| f(a, b)

        3引数:
          - partial!(f, a, __, __)  -> |b, c| f(a, b, c)
          - partial!(f, __, b, __)  -> |a, c| f(a, b, c)
          - partial!(f, __, __, c)  -> |a, b| f(a, b, c)
          - partial!(f, a, b, __)  -> |c| f(a, b, c)
          - partial!(f, a, __, c)  -> |b| f(a, b, c)
          - partial!(f, __, b, c)  -> |a| f(a, b, c)

        4-6引数: 同様のパターン

    examples:
      - description: 基本的な部分適用（最初の引数を固定）
        code: |
          use functional_rusty::compose::__;
          fn add(a: i32, b: i32) -> i32 { a + b }

          let add_five = partial!(add, 5, __);
          assert_eq!(add_five(3), 8);
          assert_eq!(add_five(10), 15);

      - description: 2番目の引数を固定
        code: |
          use functional_rusty::compose::__;
          fn divide(a: f64, b: f64) -> f64 { a / b }

          let half = partial!(divide, __, 2.0);
          assert_eq!(half(10.0), 5.0);
          assert_eq!(half(7.0), 3.5);

      - description: 3引数関数の部分適用
        code: |
          use functional_rusty::compose::__;
          fn format_greeting(greeting: &str, name: &str, punctuation: &str) -> String {
              format!("{}, {}{}", greeting, name, punctuation)
          }

          let hello_with_exclamation = partial!(format_greeting, "Hello", __, "!");
          assert_eq!(hello_with_exclamation("Alice"), "Hello, Alice!");
          assert_eq!(hello_with_exclamation("Bob"), "Hello, Bob!");

      - description: compose との組み合わせ
        code: |
          use functional_rusty::compose::__;
          fn multiply(a: i32, b: i32) -> i32 { a * b }
          fn add(a: i32, b: i32) -> i32 { a + b }

          let double = partial!(multiply, 2, __);
          let add_ten = partial!(add, 10, __);

          let double_then_add_ten = compose!(add_ten, double);
          assert_eq!(double_then_add_ten(5), 20); // add_ten(double(5)) = add_ten(10) = 20

    edge_cases:
      - description: 全ての引数を固定（thunk の生成）
        code: |
          fn get_value(a: i32, b: i32) -> i32 { a + b }

          // 全ての引数を固定すると、引数なしの関数（thunk）になる
          let thunk = partial!(get_value, 1, 2);
          assert_eq!(thunk(), 3);

      - description: プレースホルダーのみ（恒等的な部分適用）
        code: |
          use functional_rusty::compose::__;
          fn add(a: i32, b: i32) -> i32 { a + b }

          // 全てプレースホルダーの場合、元の関数と同等
          let same_as_add = partial!(add, __, __);
          assert_eq!(same_as_add(3, 5), 8);

    dependencies: []

  # ============================================================================
  # 4. curry! マクロ
  # ============================================================================
  - id: curry_macro
    name: curry! マクロ
    description: |
      カリー化マクロ。複数引数の関数を単一引数関数のチェーンに変換する。

      curry!(f)(a)(b)(c) = f(a, b, c)

      引数の数に応じた curry2!, curry3!, ..., curry6! も提供する。
      これらは型推論を助け、コンパイルエラーを分かりやすくする。

      カリー化された関数を使用することで、部分適用が自然に行える:
      - curry!(add)(5) は「5 を加える関数」を返す

    laws:
      - name: Curry-Uncurry Identity（カリー化・非カリー化の恒等性）
        description: |
          カリー化してから非カリー化すると元の関数と等価になる。
        equation: "uncurry(curry(f)) == f"
        property_test: |
          fn prop_curry_uncurry_identity<A, B, C>(
              f: impl Fn(A, B) -> C + Clone,
              a: A,
              b: B,
          ) -> bool
          where
              A: Clone,
              B: Clone,
              C: PartialEq,
          {
              let curried = curry2!(f.clone());
              let uncurried = |x, y| curried(x)(y);
              uncurried(a.clone(), b.clone()) == f(a, b)
          }

    syntax:
      - description: 2引数関数のカリー化
        example: "curry2!(add)"
        result: "|a| move |b| add(a, b)"

      - description: 3引数関数のカリー化
        example: "curry3!(f)"
        result: "|a| move |b| move |c| f(a, b, c)"

      - description: カリー化された関数の部分適用
        example: "curry2!(add)(5)"
        result: "|b| add(5, b)"

    trait_bounds:
      description: |
        カリー化では、引数は Clone を実装している必要がある。
        これは中間関数がキャプチャした値を保持するためである。

        元の関数は Fn を実装している必要がある。

      requirements:
        - "全ての引数の型: Clone を実装"
        - "元の関数: Fn + Clone を実装"

    variants:
      - name: curry2!
        arguments: 2
        example: "curry2!(|a, b| a + b)(1)(2) == 3"

      - name: curry3!
        arguments: 3
        example: "curry3!(|a, b, c| a + b + c)(1)(2)(3) == 6"

      - name: curry4!
        arguments: 4
        example: "curry4!(f)(a)(b)(c)(d) == f(a, b, c, d)"

      - name: curry5!
        arguments: 5
        example: "curry5!(f)(a)(b)(c)(d)(e) == f(a, b, c, d, e)"

      - name: curry6!
        arguments: 6
        example: "curry6!(f)(a)(b)(c)(d)(e)(f_arg) == f(a, b, c, d, e, f_arg)"

    examples:
      - description: 基本的なカリー化
        code: |
          fn add(a: i32, b: i32) -> i32 { a + b }

          let curried_add = curry2!(add);
          let add_five = curried_add(5);

          assert_eq!(add_five(3), 8);
          assert_eq!(add_five(10), 15);

          // 直接呼び出しも可能
          assert_eq!(curried_add(3)(4), 7);

      - description: 3引数関数のカリー化
        code: |
          fn volume(width: f64, height: f64, depth: f64) -> f64 {
              width * height * depth
          }

          let curried_volume = curry3!(volume);

          // 段階的に適用
          let with_width = curried_volume(2.0);
          let with_width_height = with_width(3.0);
          let result = with_width_height(4.0);

          assert_eq!(result, 24.0);

      - description: compose との組み合わせ
        code: |
          fn multiply(a: i32, b: i32) -> i32 { a * b }

          let double = curry2!(multiply)(2);
          let triple = curry2!(multiply)(3);

          let six_times = compose!(triple, double);
          assert_eq!(six_times(5), 30);

    edge_cases:
      - description: 単一引数関数のカリー化
        note: |
          単一引数関数は既にカリー化されているため、
          curry1! は提供しない。identity と同等になる。

      - description: 引数を順番に適用する必要性
        note: |
          カリー化された関数は、引数を左から順に適用する必要がある。
          任意の順序で引数を適用したい場合は partial! を使用する。

    dependencies: []

  # ============================================================================
  # 5. 補助関数
  # ============================================================================
  - id: helper_functions
    name: 補助関数
    description: |
      関数合成とパイプラインを支援する基本的な補助関数を提供する。
      これらは関数型プログラミングにおける「コンビネータ」と呼ばれる基本的な部品である。

    functions:
      - name: identity
        description: |
          恒等関数。受け取った値をそのまま返す。
          関数合成の単位元として機能する。

          identity(x) = x
          compose!(f, identity) == f
          compose!(identity, f) == f

        signature: "pub fn identity<T>(value: T) -> T"
        laws:
          - name: Identity Law
            equation: "identity(x) == x"
        examples:
          - code: |
              assert_eq!(identity(42), 42);
              assert_eq!(identity("hello"), "hello");

              // compose の単位元として
              let f = |x: i32| x * 2;
              let composed = compose!(identity, f);
              assert_eq!(composed(5), f(5));

      - name: constant
        description: |
          常に同じ値を返す関数を生成する。

          constant(x)(y) = x

          任意の入力に対して、最初に渡した値を返す関数を作る。
          これは「K コンビネータ」としても知られる。

        signature: "pub fn constant<T: Clone, U>(value: T) -> impl Fn(U) -> T"
        laws:
          - name: Constant Law
            equation: "constant(x)(y) == x for any y"
        examples:
          - code: |
              let always_five = constant(5);
              assert_eq!(always_five(100), 5);
              assert_eq!(always_five("ignored"), 5);

              // map と組み合わせて全ての要素を同じ値で置き換え
              let v: Vec<i32> = vec![1, 2, 3].into_iter().map(constant(0)).collect();
              assert_eq!(v, vec![0, 0, 0]);

      - name: flip
        description: |
          2引数関数の引数の順序を入れ替える。

          flip(f)(a, b) = f(b, a)

          これにより、部分適用の柔軟性が向上する。

        signature: "pub fn flip<A, B, C, F>(f: F) -> impl Fn(B, A) -> C where F: Fn(A, B) -> C"
        laws:
          - name: Double Flip Identity
            equation: "flip(flip(f)) == f"
          - name: Flip Definition
            equation: "flip(f)(a, b) == f(b, a)"
        examples:
          - code: |
              fn divide(a: f64, b: f64) -> f64 { a / b }

              let flipped_divide = flip(divide);

              // divide(10.0, 2.0) = 5.0
              // flip(divide)(10.0, 2.0) = divide(2.0, 10.0) = 0.2
              assert_eq!(divide(10.0, 2.0), 5.0);
              assert_eq!(flipped_divide(10.0, 2.0), 0.2);

              // 部分適用と組み合わせ
              // 「2で割る」ではなく「何かを2で割る」
              let divide_by_two = partial!(flipped_divide, 2.0, _);
              assert_eq!(divide_by_two(10.0), 5.0);

    dependencies: []

# エッジケースと制限事項
edge_cases:
  - id: empty_compose
    description: |
      compose! に関数を渡さない場合の動作。
      コンパイルエラーとなるべき。
    expected_behavior: "コンパイルエラー: 少なくとも1つの関数が必要"

  - id: type_mismatch_compose
    description: |
      型が合わない関数を compose しようとした場合。
    expected_behavior: "コンパイルエラー: 関数の入出力の型が一致しない"
    example: |
      fn f(x: i32) -> String { x.to_string() }
      fn g(x: f64) -> i32 { x as i32 }
      // compose!(f, g) は型エラー: f は i32 を受け取るが、g は f64 を受け取る

  - id: closure_capture_ownership
    description: |
      所有権をキャプチャするクロージャの compose での扱い。
    expected_behavior: |
      FnOnce のクロージャは compose! では使用できない。
      Fn を実装するクロージャのみ使用可能。
    workaround: |
      pipe! を使用するか、クロージャを Arc で共有する。

  - id: recursive_composition
    description: |
      compose の結果を再び compose に渡す場合。
    expected_behavior: "正常に動作し、結合律が成り立つ"
    example: |
      let f = compose!(a, b);
      let g = compose!(f, c);  // compose!(a, b, c) と等価

# テスト戦略
testing_strategy:
  property_based_testing:
    description: |
      各マクロと関数の法則をプロパティベーステストで検証する。
      proptest クレートを使用し、様々な入力に対して法則が成り立つことを確認。
    test_cases:
      - "compose の結合律"
      - "compose の左右恒等律"
      - "pipe と compose の等価性"
      - "curry-uncurry の恒等性"
      - "flip の二重適用が恒等"
      - "constant の定数性"

  unit_tests:
    description: |
      各マクロと関数の基本的な動作を単体テストで確認。
    test_cases:
      - "compose! の基本動作（2関数、3関数、...）"
      - "pipe! の基本動作"
      - "partial! の各パターン（2-6引数、様々なプレースホルダー位置）"
      - "curry2! - curry6! の基本動作"
      - "identity, constant, flip の基本動作"

  integration_tests:
    description: |
      マクロと関数の組み合わせをテスト。
    test_cases:
      - "compose と partial の組み合わせ"
      - "pipe と curry の組み合わせ"
      - "Phase 1 の型クラス（Functor, Monad）との組み合わせ"

  error_case_tests:
    description: |
      コンパイルエラーが期待通りに発生することを確認。
      trybuild クレートを使用。
    test_cases:
      - "型の不一致"
      - "引数の数の不一致"
      - "不正なプレースホルダーパターン"

# 実装上の考慮事項
implementation_notes:
  macro_design:
    description: |
      declarative macro (macro_rules!) と procedural macro の選択:

      - compose!, pipe!: declarative macro で十分
        - パターンマッチで可変長引数を処理
        - 再帰的なマクロ展開で任意の数の関数を処理

      - partial!: declarative macro で実装可能だが複雑
        - プレースホルダーのパターン数が多い
        - 各パターンを個別に定義する必要がある

      - curry2! - curry6!: declarative macro で実装
        - 引数の数ごとに別のマクロを提供
        - 型推論とエラーメッセージの改善のため

  type_inference:
    description: |
      Rust の型推論との相性を考慮した設計:

      - マクロ展開後のコードが型推論しやすいように設計
      - 必要に応じて型ヒントを追加できるようにする
      - コンパイルエラーが分かりやすいようにマクロを設計

  performance:
    description: |
      性能に関する考慮事項:

      - compose! の展開結果は、ネストした関数呼び出しに最適化される
      - 中間クロージャは可能な限りインライン化される
      - Clone の呼び出しを最小限に抑える設計

# 将来の拡張
future_extensions:
  - name: 可変長 curry
    description: |
      任意の引数数に対応する curry! マクロ。
      現在は curry2! - curry6! として提供するが、
      将来的には procedural macro で任意の引数数に対応可能。

  - name: async 関数の合成
    description: |
      async 関数を compose するための async_compose! マクロ。
      Future を返す関数の合成を自然に記述できるようにする。

  - name: 自動カリー化
    description: |
      #[curry] attribute macro で関数を自動的にカリー化形式に変換。

  - name: パイプライン演算子のカスタム構文
    description: |
      proc-macro で |> 演算子風の構文を提供する可能性の検討。
      （Rust の構文制約により限定的になる可能性がある）
