# Phase 9.3: PersistentTreeMap<K, V> への Hash トレイト追加 - 要件定義
# PersistentTreeMap に Hash トレイトを実装し、ハッシュコレクションでの使用を可能にする

version: "1.0.0"
created_at: "2026-01-02"
phase_id: phase_9_3
phase_name: PersistentTreeMap Hash トレイト実装
phase_name_en: PersistentTreeMap Hash Trait Implementation

# =============================================================================
# 概要（Overview）
# =============================================================================

overview:
  description: |
    PersistentTreeMap<K, V> に Hash トレイトを実装する。
    これにより、PersistentTreeMap を HashMap のキーや HashSet の要素として使用可能になる。

    現在 PersistentTreeMap には Debug, PartialEq, Eq が実装されているが、
    Hash は未実装である。順序付きマップ（赤黒木ベース）であるため、
    キー順序でイテレーションし、各 (key, value) ペアを順番にハッシュする
    シンプルな実装が可能。

  goals:
    - PersistentTreeMap<K, V> に Hash トレイトを実装する（K: Hash, V: Hash 制約）
    - Hash の一貫性を保証する（a == b ならば hash(a) == hash(b)）
    - 既存の PartialEq/Eq 実装との整合性を維持する
    - パフォーマンスを考慮した効率的なハッシュ計算

  non_goals:
    - 既存の PartialEq/Eq 実装の変更
    - Hash アルゴリズムのカスタマイズ機能
    - スレッドセーフ版（Arc）への対応（本フェーズのスコープ外）

  functional_programming_principles:
    referential_transparency: |
      Hash トレイトの実装は純粋関数として振る舞う。
      同じマップに対して常に同じハッシュ値を返す。

    composability: |
      ハッシュ計算は各エントリの (key, value) ペアのハッシュを順に結合することで行う。
      キー順序でイテレーションするため、構造を反映した一貫したハッシュ値が得られる。

# =============================================================================
# 機能要件（Functional Requirements）
# =============================================================================

functional_requirements:
  - id: FR-001
    name: Hash トレイト実装
    priority: critical
    description: |
      PersistentTreeMap<K, V> に std::hash::Hash トレイトを実装する。
      K: Hash, V: Hash の制約を持つ場合にのみ Hash が有効になる。
      また、順序付きマップの特性を活かし、K: Clone + Ord の制約も必要。

    location: src/persistent/treemap.rs

    trait_implementation: |
      use std::hash::{Hash, Hasher};

      impl<K, V> Hash for PersistentTreeMap<K, V>
      where
          K: Clone + Ord + Hash,
          V: Clone + Hash,
      {
          fn hash<H: Hasher>(&self, state: &mut H) {
              // 長さをハッシュすることで、異なるサイズのマップを区別
              self.length.hash(state);
              // 各エントリをキー順でハッシュ
              for (key, value) in self.iter() {
                  key.hash(state);
                  value.hash(state);
              }
          }
      }

    design_rationale: |
      1. 長さを先にハッシュする理由:
         - 異なるサイズのマップが同じハッシュ値になる可能性を減らす
         - 例: {1: "a"} と {1: "a", 2: ""} の区別が容易になる

      2. キー順でハッシュする理由:
         - PersistentTreeMap は赤黒木ベースの順序付きマップである
         - iter() はキー順（in-order traversal）でエントリを返す
         - {1: "a", 2: "b"} と {2: "b", 1: "a"} は等しいとみなされるため、
           同じ順序（キー順）でハッシュすることで一貫性を保証
         - PartialEq の実装と一貫性がある

      3. キーと値の両方をハッシュする理由:
         - マップは (key, value) ペアの集合である
         - 同じキーでも異なる値を持つマップは異なるハッシュ値を持つべき

    acceptance_criteria:
      - K: Clone + Ord + Hash, V: Clone + Hash の場合に PersistentTreeMap<K, V>: Hash が成り立つこと
      - 空マップもハッシュ可能であること
      - ハッシュ計算が全エントリを考慮すること

  - id: FR-002
    name: Hash-Eq 一貫性
    priority: critical
    description: |
      Hash トレイトの基本法則として、
      a == b ならば hash(a) == hash(b) を満たす必要がある。

      これは Rust の標準ライブラリで要求される Hash と Eq の一貫性である。

      PersistentTreeMap の PartialEq 実装は:
      - 長さが同じ
      - 全てのキーが存在し、対応する値が等しい
      を条件としている。

      Hash 実装も同じ条件でハッシュ値を計算するため、一貫性が保証される。

    verification: |
      プロパティベーステストで検証:
      - 同じエントリから構築されたマップは同じハッシュ値を持つ
      - 等しいマップ（a == b）は同じハッシュ値を持つ
      - 挿入順序が異なっても、同じエントリを持つマップは同じハッシュ値を持つ

    acceptance_criteria:
      - PartialEq で等しいマップは同じハッシュ値を持つこと
      - 構造的に同一のマップは同じハッシュ値を持つこと
      - 異なる挿入順序でも同じ結果のマップは同じハッシュ値を持つこと

  - id: FR-003
    name: HashMap/HashSet での使用
    priority: high
    description: |
      Hash 実装により、PersistentTreeMap を以下の用途で使用可能にする:
      - HashMap<PersistentTreeMap<K, V>, U> のキー
      - HashSet<PersistentTreeMap<K, V>> の要素
      - PersistentHashMap<PersistentTreeMap<K, V>, U> のキー
      - PersistentHashSet<PersistentTreeMap<K, V>> の要素

    example: |
      use std::collections::{HashMap, HashSet};
      use lambars::persistent::PersistentTreeMap;

      // HashMap のキーとして使用
      let mut map: HashMap<PersistentTreeMap<i32, String>, &str> = HashMap::new();
      let treemap = PersistentTreeMap::new()
          .insert(1, "one".to_string())
          .insert(2, "two".to_string());
      map.insert(treemap.clone(), "first");
      assert_eq!(map.get(&treemap), Some(&"first"));

      // HashSet の要素として使用
      let mut set: HashSet<PersistentTreeMap<i32, String>> = HashSet::new();
      set.insert(PersistentTreeMap::new().insert(1, "one".to_string()));
      set.insert(PersistentTreeMap::new().insert(2, "two".to_string()));
      assert!(set.contains(&PersistentTreeMap::new().insert(1, "one".to_string())));

    acceptance_criteria:
      - HashMap のキーとして使用できること
      - HashSet の要素として使用できること
      - PersistentHashMap のキーとして使用できること
      - PersistentHashSet の要素として使用できること

# =============================================================================
# 非機能要件（Non-Functional Requirements）
# =============================================================================

non_functional_requirements:
  - id: NFR-001
    name: パフォーマンス
    priority: high
    description: |
      ハッシュ計算の計算量は O(n) であること（n = マップのエントリ数）。
      各エントリを一度だけ走査してハッシュ値を計算する。

    complexity:
      time: O(n)
      space: O(1)

    notes: |
      - iter() メソッドを使用することでキー順のトラバースが可能
      - iter() は内部で Vec を構築するが、これは既存の実装
      - 各エントリの hash() 呼び出しはインライン化される可能性が高い

  - id: NFR-002
    name: 安全性
    priority: critical
    description: |
      実装は #![forbid(unsafe_code)] ポリシーに準拠する。
      unsafe コードは使用しない。

    verification: |
      - コンパイル時に unsafe_code 禁止が適用されること
      - clippy の unsafe 関連警告がないこと

  - id: NFR-003
    name: 後方互換性
    priority: critical
    description: |
      既存のコードに影響を与えない追加的な変更であること。
      - 既存の Debug, PartialEq, Eq 実装に変更なし
      - 既存の API に変更なし
      - 新しい Hash 実装は追加のみ

# =============================================================================
# テスト要件（Test Requirements）
# =============================================================================

test_requirements:
  unit_tests:
    location: tests/persistent_treemap_tests.rs
    description: |
      既存のテストファイルに Hash 関連のテストを追加する。

    categories:
      - name: 基本ハッシュテスト
        tests:
          - name: test_empty_treemap_hash
            description: 空マップがハッシュ可能であること
            test: |
              use std::collections::hash_map::DefaultHasher;
              use std::hash::{Hash, Hasher};

              let empty: PersistentTreeMap<i32, String> = PersistentTreeMap::new();
              let mut hasher = DefaultHasher::new();
              empty.hash(&mut hasher);
              let hash_value = hasher.finish();
              // ハッシュ値が計算できることを確認
              assert!(hash_value != 0 || hash_value == 0); // 常に true だが計算されることを確認

          - name: test_singleton_treemap_hash
            description: 単一エントリマップがハッシュ可能であること
            test: |
              let map = PersistentTreeMap::singleton(42, "answer".to_string());
              let mut hasher = DefaultHasher::new();
              map.hash(&mut hasher);
              let _ = hasher.finish();

          - name: test_multi_entry_treemap_hash
            description: 複数エントリマップがハッシュ可能であること
            test: |
              let map = PersistentTreeMap::new()
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string())
                  .insert(3, "three".to_string());
              let mut hasher = DefaultHasher::new();
              map.hash(&mut hasher);
              let _ = hasher.finish();

      - name: Hash-Eq 一貫性テスト
        tests:
          - name: test_equal_treemaps_same_hash
            description: 等しいマップは同じハッシュ値を持つ
            test: |
              let map1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string());
              let map2 = PersistentTreeMap::new()
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string());
              assert_eq!(map1, map2);

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              map1.hash(&mut hasher1);
              map2.hash(&mut hasher2);
              assert_eq!(hasher1.finish(), hasher2.finish());

          - name: test_different_insert_order_same_hash
            description: 挿入順序が異なっても等しいマップは同じハッシュ値を持つ
            test: |
              let map1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string())
                  .insert(3, "three".to_string());
              let map2 = PersistentTreeMap::new()
                  .insert(3, "three".to_string())
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string());
              assert_eq!(map1, map2);

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              map1.hash(&mut hasher1);
              map2.hash(&mut hasher2);
              assert_eq!(hasher1.finish(), hasher2.finish());

          - name: test_different_treemaps_likely_different_hash
            description: 異なるマップは（高確率で）異なるハッシュ値を持つ
            test: |
              let map1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string());
              let map2 = PersistentTreeMap::new()
                  .insert(1, "ONE".to_string());
              assert_ne!(map1, map2);

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              map1.hash(&mut hasher1);
              map2.hash(&mut hasher2);
              // 衝突の可能性はあるが、この例では異なるはず
              assert_ne!(hasher1.finish(), hasher2.finish());

          - name: test_different_keys_different_hash
            description: 異なるキーを持つマップは（高確率で）異なるハッシュ値を持つ
            test: |
              let map1 = PersistentTreeMap::new()
                  .insert(1, "value".to_string());
              let map2 = PersistentTreeMap::new()
                  .insert(2, "value".to_string());

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              map1.hash(&mut hasher1);
              map2.hash(&mut hasher2);
              assert_ne!(hasher1.finish(), hasher2.finish());

          - name: test_different_size_different_hash
            description: 異なるサイズのマップは（高確率で）異なるハッシュ値を持つ
            test: |
              let map1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string());
              let map2 = PersistentTreeMap::new()
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string());

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              map1.hash(&mut hasher1);
              map2.hash(&mut hasher2);
              assert_ne!(hasher1.finish(), hasher2.finish());

      - name: コレクション使用テスト
        tests:
          - name: test_hashmap_key
            description: HashMap のキーとして使用可能
            test: |
              use std::collections::HashMap;

              let mut map: HashMap<PersistentTreeMap<i32, String>, &str> = HashMap::new();
              let key1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string());
              let key2 = PersistentTreeMap::new()
                  .insert(2, "two".to_string());

              map.insert(key1.clone(), "first");
              map.insert(key2.clone(), "second");

              assert_eq!(map.get(&key1), Some(&"first"));
              assert_eq!(map.get(&key2), Some(&"second"));
              // 同じエントリを持つ新しいマップでも検索可能
              assert_eq!(
                  map.get(&PersistentTreeMap::new().insert(1, "one".to_string())),
                  Some(&"first")
              );

          - name: test_hashset_element
            description: HashSet の要素として使用可能
            test: |
              use std::collections::HashSet;

              let mut set: HashSet<PersistentTreeMap<i32, String>> = HashSet::new();
              set.insert(PersistentTreeMap::new().insert(1, "one".to_string()));
              set.insert(PersistentTreeMap::new().insert(2, "two".to_string()));
              set.insert(PersistentTreeMap::new().insert(1, "one".to_string())); // 重複

              assert_eq!(set.len(), 2);
              assert!(set.contains(&PersistentTreeMap::new().insert(1, "one".to_string())));
              assert!(set.contains(&PersistentTreeMap::new().insert(2, "two".to_string())));
              assert!(!set.contains(&PersistentTreeMap::new().insert(3, "three".to_string())));

          - name: test_persistent_hashset_element
            description: PersistentHashSet の要素として使用可能
            test: |
              use lambars::persistent::PersistentHashSet;

              let treemap1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string());
              let treemap2 = PersistentTreeMap::new()
                  .insert(2, "two".to_string());

              let set = PersistentHashSet::new()
                  .insert(treemap1.clone())
                  .insert(treemap2.clone());

              assert!(set.contains(&treemap1));
              assert!(set.contains(&treemap2));

  law_tests:
    location: tests/persistent_treemap_laws.rs
    framework: proptest
    description: |
      プロパティベーステストで Hash 法則を検証する。

    laws:
      - name: hash_eq_consistency
        description: "a == b ならば hash(a) == hash(b)"
        property: |
          proptest! {
              #[test]
              fn prop_hash_eq_consistency(
                  entries in prop::collection::vec((any::<i32>(), any::<i32>()), 0..50)
              ) {
                  let map1: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();
                  let map2: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();

                  prop_assert_eq!(map1, map2);

                  let mut hasher1 = DefaultHasher::new();
                  let mut hasher2 = DefaultHasher::new();
                  map1.hash(&mut hasher1);
                  map2.hash(&mut hasher2);
                  prop_assert_eq!(hasher1.finish(), hasher2.finish());
              }
          }

      - name: hash_deterministic
        description: "同じマップは常に同じハッシュ値を持つ"
        property: |
          proptest! {
              #[test]
              fn prop_hash_deterministic(
                  entries in prop::collection::vec((any::<i32>(), any::<i32>()), 0..50)
              ) {
                  let map: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();

                  let mut hasher1 = DefaultHasher::new();
                  let mut hasher2 = DefaultHasher::new();
                  map.hash(&mut hasher1);
                  map.hash(&mut hasher2);
                  prop_assert_eq!(hasher1.finish(), hasher2.finish());
              }
          }

      - name: hash_insert_order_independent
        description: "挿入順序に依存しないハッシュ値"
        property: |
          proptest! {
              #[test]
              fn prop_hash_insert_order_independent(
                  entries in prop::collection::vec((any::<i32>(), any::<i32>()), 2..20)
              ) {
                  use rand::seq::SliceRandom;
                  use rand::thread_rng;

                  let map1: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();

                  let mut shuffled = entries.clone();
                  shuffled.shuffle(&mut thread_rng());
                  let map2: PersistentTreeMap<i32, i32> = shuffled.iter().cloned().collect();

                  // 同じキーに対する最後の値が使われるため、結果は同じ
                  prop_assert_eq!(map1, map2);

                  let mut hasher1 = DefaultHasher::new();
                  let mut hasher2 = DefaultHasher::new();
                  map1.hash(&mut hasher1);
                  map2.hash(&mut hasher2);
                  prop_assert_eq!(hasher1.finish(), hasher2.finish());
              }
          }

  integration_tests:
    location: tests/persistent_treemap_tests.rs
    description: |
      他の永続データ構造との統合テスト。

    scenarios:
      - name: treemap_as_hashmap_key_with_persistent_values
        description: |
          PersistentTreeMap をキーとして使用し、
          値に他の永続データ構造を持つ HashMap のテスト。

      - name: nested_treemap_hash
        description: |
          PersistentTreeMap<K, PersistentTreeMap<K, V>> のハッシュが正しく動作すること。

      - name: treemap_with_persistent_list_values
        description: |
          PersistentTreeMap<K, PersistentList<V>> のハッシュが正しく動作すること。

# =============================================================================
# 受け入れ基準（Acceptance Criteria）
# =============================================================================

acceptance_criteria:
  functional:
    - id: AC-001
      description: PersistentTreeMap<K, V> で K: Clone + Ord + Hash, V: Clone + Hash の場合に Hash が実装されていること
      verification: "コンパイルが成功すること"

    - id: AC-002
      description: 空マップ、単一エントリマップ、複数エントリマップすべてがハッシュ可能であること
      verification: "ユニットテストが成功すること"

    - id: AC-003
      description: 等しいマップが同じハッシュ値を持つこと（Hash-Eq 一貫性）
      verification: "プロパティベーステストが成功すること"

    - id: AC-004
      description: 挿入順序が異なっても同じエントリを持つマップは同じハッシュ値を持つこと
      verification: "プロパティベーステストが成功すること"

    - id: AC-005
      description: HashMap のキーとして使用できること
      verification: "統合テストが成功すること"

    - id: AC-006
      description: HashSet の要素として使用できること
      verification: "統合テストが成功すること"

    - id: AC-007
      description: PersistentHashMap のキーとして使用できること
      verification: "統合テストが成功すること"

    - id: AC-008
      description: PersistentHashSet の要素として使用できること
      verification: "統合テストが成功すること"

  code_quality:
    - id: AC-Q01
      description: 全てのテストが通過すること
      verification: "cargo test が成功すること"

    - id: AC-Q02
      description: clippy 警告がないこと
      verification: "cargo clippy -- -D warnings が成功すること"

    - id: AC-Q03
      description: unsafe コードを使用していないこと
      verification: "#![forbid(unsafe_code)] がエラーを出さないこと"

    - id: AC-Q04
      description: ドキュメントが完備していること
      verification: "cargo doc が警告なしで成功すること"

  performance:
    - id: AC-P01
      description: ハッシュ計算の計算量が O(n) であること
      verification: "マップのエントリ数に比例した時間で完了すること"

# =============================================================================
# 成果物（Artifacts）
# =============================================================================

artifacts:
  source_files:
    - path: src/persistent/treemap.rs
      description: Hash トレイト実装の追加
      changes:
        - "use std::hash::{Hash, Hasher}; の追加（既存の use 文に統合）"
        - "impl<K, V> Hash for PersistentTreeMap<K, V> where K: Clone + Ord + Hash, V: Clone + Hash の追加"

  test_files:
    - path: tests/persistent_treemap_tests.rs
      description: Hash 関連ユニットテストの追加

    - path: tests/persistent_treemap_laws.rs
      description: Hash 法則のプロパティベーステストの追加

# =============================================================================
# 依存関係（Dependencies）
# =============================================================================

dependencies:
  internal:
    - lambars::persistent::PersistentTreeMap
    - lambars::persistent::PersistentHashMap (テスト用)
    - lambars::persistent::PersistentHashSet (テスト用)
    - lambars::persistent::PersistentList (統合テスト用)

  external: []

  dev_dependencies:
    - rstest: "0.18"
      reason: パラメータ化テスト

    - proptest: "1.0"
      reason: プロパティベーステスト

    - rand: "0.8"
      reason: プロパティテストでのシャッフル用

# =============================================================================
# 参照（References）
# =============================================================================

references:
  - name: "Rust std::hash::Hash"
    url: "https://doc.rust-lang.org/std/hash/trait.Hash.html"
    description: |
      Rust 標準ライブラリの Hash トレイト。
      Hash と Eq の一貫性要件が記載されている。

  - name: "Rust std::collections::HashMap"
    url: "https://doc.rust-lang.org/std/collections/struct.HashMap.html"
    description: |
      HashMap のキーに必要なトレイト境界（Eq + Hash）の説明。

  - name: "既存の PersistentTreeMap 実装"
    location: src/persistent/treemap.rs
    description: |
      Debug（line 1077-1081）、PartialEq（line 1057-1073）、Eq（line 1075）の
      既存実装を参考にする。
      iter() メソッド（line 786-793）はキー順でエントリを返す。

  - name: "PersistentList Hash 要件定義"
    location: docs/phase_9_requirements/phase_9_1_list_hash.yaml
    description: |
      同様の Hash トレイト実装の要件定義。
      PersistentTreeMap は順序付きマップであるため、
      (key, value) ペアをキー順でハッシュする点が異なる。
