# Bank Sample 要件定義
#
# 概要:
#   lambarsライブラリを活用した銀行口座管理サンプルアプリケーション。
#   Event Sourcing / CQRS パターンで実装し、関数型プログラミングの実践例を提供する。
#
# 設計方針:
#   1. 「必要な抽象のみ採用」を原則とし、ユースケースに適合した機能選択を行う
#   2. Onion Architecture + Event Sourcing / CQRS で関数型アーキテクチャを実現
#   3. ドメイン層は純粋関数のみ、副作用はエフェクトシステムで分離
#   4. 実行境界（Interpreter/Runner）と純粋計算領域を厳密に区分する
#   5. 効果表現は用途に応じて選択:
#      - コマンドハンドラ: Reader + Writer（MTLスタイル）
#      - DSL構築（任意）: Freer/Algebraic Effects
#      - CPS/Continuationは使用しない
#
# 参照:
#   - samples/order/ - 既存サンプル（IO, Lazy, Lens, compose!）
#   - docs/internal/plans/ - 設計計画
#   - Domain Modeling Made Functional (F#)

version: "1.1.0"
name: "bank-sample"
description: |
  lambarsライブラリを実践的に活用するサンプルWebアプリケーション。
  銀行口座管理ドメイン（入金、出金、送金、残高照会、取引履歴）を
  Event Sourcing / CQRS パターンで実装する。

  主要な技術スタック:
  - Axum: Webフレームワーク
  - PostgreSQL: イベントストア
  - Redis: Read Modelキャッシュ
  - SQS (LocalStack): メッセージキュー

# 背景・動機
background:
  problem: |
    既存のsamples/order/はlambarsの一部機能（IO, Lazy, Lens, compose!）のみを使用しており、
    ライブラリの多くの機能の使用例が示されていない。
  motivation: |
    1. lambarsの主要機能の実践的な使用例を提供
    2. 関数型プログラミングによるWebアプリケーション構築のベストプラクティスを示す
    3. Event Sourcing / CQRSパターンと関数型プログラミングの親和性を実証
    4. 実運用に近い構成（PostgreSQL, Redis, SQS）での実装例を提供
  prior_art:
    - name: "samples/order"
      description: |
        F#の「Domain Modeling Made Functional」をRustで実装したサンプル。
        IO, Lazy, Lens, compose!を使用。
    - name: "Haskell Event Store"
      description: |
        HaskellでのEvent Sourcingパターン実装。
        Foldable, Traversable, Monad変換器を活用したイベント処理。

# ======================================================================
# 機能分類（必須/任意）
# ======================================================================
# Codexレビュー指摘: 「全機能網羅」ではなく「必要な抽象のみ採用」を原則とする
feature_classification:
  required:
    description: |
      Event Sourcing / CQRS パターンの実装に必須の機能。
      これらがなければアーキテクチャが成立しない。
    features:
      - name: "Foldable"
        reason: "イベント列の畳み込みによる状態復元に必須"
      - name: "Semigroup/Monoid"
        reason: "金額の集計、イベント列の結合に必須"
      - name: "Either"
        reason: "ドメインエラー表現に必須"
      - name: "Lens"
        reason: "アグリゲート状態の不変更新に必須"
      - name: "Prism"
        reason: "イベント型のパターンマッチングに必須"
      - name: "PersistentList"
        reason: "イベントログの不変管理に必須"
      - name: "PersistentHashMap"
        reason: "アグリゲートキャッシュに必須"
      - name: "AsyncIO"
        reason: "非同期DB/外部サービス操作に必須"
      - name: "Reader"
        reason: "依存性注入に必須"
      - name: "Trampoline"
        reason: "大量イベント再生のスタック安全性に必須"
      - name: "Writer"
        reason: "コマンドハンドラでの監査ログ収集に必須（ログ専用、メッセージはbuild_sqs_messagesで構築）"

  recommended:
    description: |
      アーキテクチャの品質向上に寄与する機能。
      なくても動作するが、関数型プログラミングの利点を示すために採用。
    features:
      - name: "Applicative"
        reason: "複数フィールドの並列バリデーションで品質向上"
      - name: "Traversable"
        reason: "エフェクト付きマッピングでコードの表現力向上"
      - name: "Bifunctor"
        reason: "Result両側変換でエラーハンドリング簡潔化"
      - name: "Iso"
        reason: "DTO変換の双方向性を保証"
      - name: "compose!/pipe!"
        reason: "関数合成でパイプライン表現力向上"
      - name: "for_!/for_async!"
        reason: "モナド内包記法で可読性向上"
      - name: "PersistentVector"
        reason: "インデックスアクセスが必要な履歴データに適切"
      - name: "PersistentTreeMap"
        reason: "時系列データのソート済み保持に適切"
      - name: "State"
        reason: "純粋な状態変換の表現に有用"

  optional:
    description: |
      デモ/学習目的で含める機能。
      ユースケースへの適合度は低いが、機能の使用例として価値がある。
    features:
      - name: "Freer/Algebraic Effects"
        reason: "DSL構築のデモ。本番では過剰だが学習価値あり"
      - name: "ConcurrentLazy"
        reason: "設定の遅延読み込みデモ。シンプルな実装でも可"
      - name: "PersistentHashSet"
        reason: "処理済みIDチェックのデモ。HashMapでも代替可"
      - name: "Optional (optics)"
        reason: "Nullableフィールド操作のデモ"
      - name: "Traversal (optics)"
        reason: "コレクション操作のデモ"

  excluded:
    description: |
      本サンプルでは使用しない機能とその理由。
    features:
      - name: "Continuation/CPS"
        reason: |
          Codexレビュー指摘: Freer/Algebraic Effectsと重複し、
          効果表現が多重化して理解コストが増加する。
          効果表現はFreerに統一する。
      - name: "PersistentDeque"
        reason: |
          Codexレビュー指摘: メッセージキューにPersistentDequeを使用すると
          「外部キューの代替」になり、CQRSの境界が曖昧になる。
          メッセージキューは外部SQSを直接使用する。
      - name: "Alternative (フォールバック用途)"
        reason: |
          Codexレビュー指摘: 残高不足時のフォールバックにAlternativeを使用すると
          「業務上の拒否」と「分岐条件」の意味論が混在する。
          専用のFundingSource型とルールエンジンで表現する。

# ======================================================================
# 実行境界の定義
# ======================================================================
# Codexレビュー指摘: 実行境界（Interpreter/Runner）と純粋計算領域を明確に区分する
execution_boundaries:
  description: |
    副作用の実行点を明確に定義し、純粋計算領域からの分離を保証する。
    「計算の構築」と「計算の実行」を厳密に分離する。

  pure_computation_layer:
    description: |
      副作用を含まない純粋な計算のみを行う層。
      ドメイン層とアプリケーション層の大部分が該当。
    components:
      - name: "ドメイン層全体"
        description: "値オブジェクト、イベント、アグリゲート、DSL"
      - name: "バリデーションロジック"
        description: "Applicativeによる検証計算の構築"
      - name: "イベント適用ロジック"
        description: "Foldable/Trampolineによる状態復元計算の構築"
      - name: "Writerによる監査ログ収集"
        description: "監査ログの蓄積は純粋計算、永続化はIO境界で実行。メッセージはWriterではなくbuild_sqs_messagesで構築"
      - name: "DSLプログラム構築"
        description: "Freerによる計算の記述、実行はインタプリタで"

  io_execution_layer:
    description: |
      副作用を実際に実行する層。明確なRunnerを定義する。
    components:
      - name: "main関数"
        description: "アプリケーションのエントリポイント。最上位のIO実行"
      - name: "Axumハンドラ"
        description: "HTTPリクエスト処理のIO実行点"
      - name: "EventStoreRunner"
        description: "AsyncIO<Result<_, _>>をawaitで実行"
      - name: "SqsPublisherRunner"
        description: "メッセージ送信のIO実行点（build_sqs_messagesの結果を受け取りsend_sqs_messagesで送信）"
      - name: "FreerInterpreter"
        description: "DSLプログラムをIOに変換して実行"

  boundary_rules:
    - "純粋計算層からIOを直接呼び出さない"
    - "Writerの蓄積結果（監査ログ）はIO実行層で永続化"
    - "SQSメッセージはイベントからbuild_sqs_messagesで構築し、IO実行層でsend_sqs_messagesで送信"
    - "Freer/Algebraic EffectsはインタプリタでIOに変換"
    - "テストでは純粋計算のみを検証可能にする"

# 要件一覧
requirements:
  # ======================================================================
  # 1. ドメイン層（純粋関数）
  # ======================================================================
  - id: domain_value_objects
    name: "値オブジェクト"
    description: |
      ドメインの基本的な値を表現する不変な型を定義する。
      Smart Constructorパターンでバリデーションを組み込む。

    methods:
      - name: "AccountId::create"
        signature: "fn create(value: String) -> Either<ValidationError, AccountId>"
        description: |
          UUID v7形式の口座IDを生成。無効な形式はEither::Leftを返す。
        examples:
          - description: "有効なUUID v7からAccountIdを生成"
            code: |
              let id = AccountId::create("01234567-89ab-7def-0123-456789abcdef".to_string());
              assert!(id.is_right());

      - name: "Money::combine"
        signature: "fn combine(self, other: Self) -> Self"
        description: |
          Semigroup実装。同一通貨の金額を加算する。
        examples:
          - description: "2つの金額を加算"
            code: |
              let a = Money::new(Decimal::new(100, 0), Currency::JPY);
              let b = Money::new(Decimal::new(50, 0), Currency::JPY);
              let sum = a.combine(b);
              assert_eq!(sum.amount(), Decimal::new(150, 0));

      - name: "Money::empty"
        signature: "fn empty() -> Self"
        description: |
          Monoid実装。金額ゼロの単位元を返す。
        examples:
          - description: "単位元の生成"
            code: |
              let zero = Money::empty();
              assert_eq!(zero.amount(), Decimal::ZERO);

    implementations:
      - type: "AccountId"
        description: |
          UUID v7形式の口座識別子。Eq, Hash, Clone実装。
      - type: "Money"
        description: |
          通貨付き金額。Semigroup, Monoid実装で集計可能。
      - type: "TransactionId"
        description: |
          冪等性キーから生成される取引識別子。
      - type: "Timestamp"
        description: |
          UTC タイムスタンプ。Ord実装で時系列ソート可能。

  - id: domain_events
    name: "ドメインイベント"
    description: |
      口座に関するすべての状態変更をイベントとして表現する。
      Prismによる型安全なパターンマッチング、Semigroupによるイベント結合を提供。

    methods:
      - name: "AccountEvent::deposited_prism"
        signature: "fn deposited_prism() -> impl Prism<AccountEvent, MoneyDeposited>"
        description: |
          入金イベントへのPrism。型安全なパターンマッチングを提供。
        examples:
          - description: "Prismによるイベント抽出"
            code: |
              let event = AccountEvent::Deposited(deposited);
              let prism = AccountEvent::deposited_prism();
              let result = prism.preview(&event);
              assert!(result.is_some());

    implementations:
      - type: "AccountEvent"
        description: |
          口座イベントのADT。Opened, Deposited, Withdrawn,
          TransferSent, TransferReceived, Closed バリアントを持つ。
      - type: "Vec<AccountEvent>"
        description: |
          Semigroup実装でイベント列を結合可能。

  - id: domain_aggregate
    name: "アグリゲート"
    description: |
      イベントの畳み込みにより口座状態を復元する。
      Lensによる不変更新、Foldableによるイベント適用を提供。

    laws:
      - name: "イベント適用の結合性"
        description: |
          イベント適用の順序を変えても最終状態は同じ。
        equation: "apply(apply(s, e1), e2) == apply(s, e1 ++ e2).fold"
        property_test: |
          #[rstest]
          fn apply_associativity(events: Vec<AccountEvent>) {
              let state1 = events.iter().fold(None, Account::apply_event);
              let state2 = Account::from_events(&events.into());
              assert_eq!(state1, state2);
          }

    methods:
      - name: "Account::from_events"
        signature: "fn from_events(events: &PersistentList<AccountEvent>) -> Option<Self>"
        description: |
          イベント列からアグリゲートを復元。Foldableのfold_leftを使用。
        examples:
          - description: "イベント列から口座状態を復元"
            code: |
              let events = PersistentList::new()
                  .cons(AccountEvent::Opened(opened))
                  .cons(AccountEvent::Deposited(deposited));
              let account = Account::from_events(&events);
              assert!(account.is_some());

      - name: "Account::balance_lens"
        signature: "fn balance_lens() -> impl Lens<Account, Money>"
        description: |
          残高フィールドへのLens。不変更新を提供。
        examples:
          - description: "Lensによる残高更新"
            code: |
              let lens = Account::balance_lens();
              let new_balance = Money::new(Decimal::new(1000, 0), Currency::JPY);
              let updated = lens.set(account, new_balance);
              assert_eq!(lens.get(&updated), &new_balance);

    implementations:
      - type: "Account"
        description: |
          口座アグリゲート。id, owner_name, balance, status, versionを持つ。

  - id: domain_funding_sources
    name: "出金元選択ルール"
    description: |
      Codexレビュー指摘対応: Alternativeの代わりに専用の型とルールエンジンで表現。
      「業務上の拒否」と「分岐条件」を明確に区別する。

      参照透過性の担保:
      - 優先順位リスト（sources）は純粋関数の引数として渡す
      - 外部設定から読み込む場合はIO境界で読み込み、引数として渡す
      - FundingSource::select自体は純粋関数として実装

    methods:
      - name: "FundingSource::select"
        signature: |
          fn select(
              account: &Account,
              amount: &Money,
              sources: &[FundingSourceType],
          ) -> Result<SelectedFunding, InsufficientFundsError>
        description: |
          優先順位に従って出金元を選択する純粋関数。
          全ての出金元で不足する場合はエラーを返す。
          sourcesは引数として渡されるため、参照透過性が保たれる。
        examples:
          - description: "出金元の選択（優先順位は引数で渡す）"
            code: |
              // 優先順位リストは外部設定からIO境界で読み込み、引数として渡す
              let sources = config.funding_priority(); // IO境界で取得済み
              let result = FundingSource::select(&account, &amount, &sources);
              match result {
                  Ok(selected) => println!("Selected: {:?}", selected.source_type),
                  Err(e) => println!("Insufficient funds: {:?}", e),
              }

    implementations:
      - type: "FundingSourceType"
        description: |
          出金元の種類。Balance, Overdraft, CreditLineのenum。
      - type: "SelectedFunding"
        description: |
          選択された出金元と金額の詳細。
      - type: "InsufficientFundsError"
        description: |
          残高不足エラー。試行した全ての出金元の情報を含む。

  - id: domain_dsl
    name: "ドメインDSL（任意）"
    description: |
      Freerモナドを使用して口座操作のDSLを構築する。
      テスト用モックインタプリタと本番用インタプリタを分離。

      注意: この機能は学習/デモ目的。本番では過剰な抽象化の可能性あり。

    methods:
      - name: "get_balance"
        signature: "fn get_balance(account_id: AccountId) -> Freer<AccountInstruction, Money>"
        description: |
          残高取得のDSLコンストラクタ。
        examples:
          - description: "残高取得DSL"
            code: |
              let program = get_balance(account_id);
              let balance = interpret_mock(program, &mut mock_state);

      - name: "transfer_program"
        signature: |
          fn transfer_program(from: AccountId, to: AccountId, amount: Money)
              -> Freer<AccountInstruction, TransferResult>
        description: |
          送金プログラムのDSL。残高確認→出金→入金の流れを表現。
        examples:
          - description: "送金DSLプログラム"
            code: |
              let program = transfer_program(from_id, to_id, amount);
              // テスト: モックインタプリタで実行
              let result = interpret_mock(program.clone(), &mut mock_state);
              // 本番: IOインタプリタで実行（IO実行境界）
              let result = interpret_io(program, &deps).run_async().await;

    implementations:
      - type: "AccountInstruction"
        description: |
          口座操作命令。GetBalance, Deposit, Withdraw, Transferバリアントを持つ。

  # ======================================================================
  # 2. アプリケーション層
  # ======================================================================
  - id: application_validation
    name: "バリデーション"
    description: |
      Applicativeを使用して複数フィールドを並列検証する。
      エラーを蓄積して一度に全てのバリデーションエラーを返す。

    methods:
      - name: "validate_deposit_command"
        signature: |
          fn validate_deposit_command(account_id: &str, amount: &MoneyDto)
              -> ValidationResult<ValidatedDeposit>
        description: |
          入金コマンドのバリデーション。Applicative::map2で並列検証。
        examples:
          - description: "並列バリデーション"
            code: |
              let result = validate_deposit_command("invalid", &negative_amount);
              // 両方のエラーが蓄積される
              assert_eq!(result.unwrap_err().errors.len(), 2);

    implementations:
      - type: "ValidationResult<A>"
        description: |
          Result<A, ValidationErrors>のエイリアス。Applicative実装で並列検証。

  - id: application_event_sourcing
    name: "イベントソーシング"
    description: |
      Trampolineを使用してスタック安全なイベント再生を実現。
      大量のイベント（数万件）でもスタックオーバーフローしない。

      重要: Trampolineの対象は純粋計算のみ。IO操作は含まない。

    methods:
      - name: "replay_events"
        signature: |
          fn replay_events<A, E>(
              initial: A,
              events: PersistentList<E>,
              apply: impl Fn(A, &E) -> A,
          ) -> Trampoline<A>
        description: |
          スタック安全なイベント再生。Trampolineで再帰をヒープに展開。
          純粋計算のみを含み、IO操作は含まない。
        examples:
          - description: "大量イベントの再生（純粋計算）"
            code: |
              // 純粋な適用関数
              let apply = |state: Option<Account>, event: &AccountEvent| {
                  Account::apply_event(state, event)
              };
              let events = generate_events(100_000);
              let trampoline = replay_events(None, events, apply);
              let state = trampoline.run(); // スタックオーバーフローしない

    implementations:
      - type: "Trampoline<A>"
        description: |
          スタック安全な再帰計算。done, suspendで構築。

  - id: application_commands
    name: "コマンドハンドラ"
    description: |
      CQRS Writeモデル。エフェクトシステム（Reader, State, Writer）を
      使用してコマンド処理を実装。

      注意: Writerで蓄積したログ/メッセージの永続化/送信はIO実行境界で行う。

    methods:
      - name: "execute_deposit"
        signature: |
          fn execute_deposit(command: DepositCommand)
              -> Reader<Dependencies, Writer<Vec<AuditLog>, Result<DepositResult, DepositError>>>
        description: |
          入金コマンドの実行。
          - Reader: 依存性（リポジトリ等）の注入
          - Writer: 監査ログの純粋な蓄積（永続化はIO境界で実行）
        examples:
          - description: "Readerで依存性注入、Writerでログ蓄積"
            code: |
              let computation = execute_deposit(command);
              // 純粋計算の実行
              let writer = computation.run(&deps);
              let (result, logs) = writer.run();
              // IO実行境界でログを永続化
              persist_audit_logs(&logs).await;

      - name: "execute_withdraw"
        signature: |
          fn execute_withdraw(command: WithdrawCommand)
              -> Reader<Dependencies, Result<WithdrawResult, WithdrawError>>
        description: |
          出金コマンドの実行。FundingSource::selectで出金元を選択。
        examples:
          - description: "出金元選択を含む出金処理"
            code: |
              let computation = execute_withdraw(command);
              let result = computation.run(&deps);

      - name: "execute_transfer"
        signature: |
          fn execute_transfer(command: TransferCommand)
              -> Reader<Dependencies, Writer<Vec<AuditLog>, Result<TransferResult, TransferError>>>
        description: |
          送金コマンドの実行。Reader + Writerで依存性注入とログ蓄積。
        examples:
          - description: "送金処理"
            code: |
              let computation = execute_transfer(command);
              let writer = computation.run(&deps);
              let (result, logs) = writer.run();

    implementations:
      - type: "DepositHandler"
        description: |
          入金コマンドハンドラ。Reader + Writerエフェクトを使用。
      - type: "WithdrawHandler"
        description: |
          出金コマンドハンドラ。FundingSource::selectで出金元選択。
      - type: "TransferHandler"
        description: |
          送金コマンドハンドラ。Reader + Writerで実装。

  - id: application_queries
    name: "クエリハンドラ"
    description: |
      CQRS Readモデル。Traversableを使用してエフェクト付きマッピングを実装。

    methods:
      - name: "get_transaction_history"
        signature: |
          fn get_transaction_history(account_id: &AccountId, params: &QueryParams)
              -> AsyncIO<Result<PersistentVector<Transaction>, QueryError>>
        description: |
          取引履歴の取得。PersistentTreeMapで時系列ソート、
          Traversableでエフェクト付き変換。
        examples:
          - description: "履歴取得とTraversable変換"
            code: |
              let history = get_transaction_history(&account_id, &params).run_async().await?;
              let enriched = history.traverse_result(|tx| enrich_transaction(tx))?;

    implementations:
      - type: "GetBalanceHandler"
        description: |
          残高照会クエリハンドラ。Redisキャッシュを参照。
      - type: "GetHistoryHandler"
        description: |
          取引履歴クエリハンドラ。PersistentTreeMapで時系列管理。

  # ======================================================================
  # 3. インフラ層
  # ======================================================================
  - id: infrastructure_config
    name: "設定管理"
    description: |
      ConcurrentLazyを使用してスレッドセーフな設定遅延読み込みを実現。

    methods:
      - name: "AppConfig::get"
        signature: "fn get() -> Arc<AppConfig>"
        description: |
          グローバル設定の取得。初回アクセス時に読み込み、以降はキャッシュ。
        examples:
          - description: "設定の遅延読み込み"
            code: |
              static CONFIG: ConcurrentLazy<AppConfig> = ConcurrentLazy::new(|| {
                  AppConfig::from_env().expect("Failed to load config")
              });
              let config = CONFIG.force();

    implementations:
      - type: "AppConfig"
        description: |
          アプリケーション設定。DATABASE_URL, REDIS_URL, SQS_ENDPOINTなど。

  - id: infrastructure_event_store
    name: "イベントストア"
    description: |
      PostgreSQLベースのイベントストア。AsyncIOで非同期DB操作。

    methods:
      - name: "append_events"
        signature: |
          fn append_events(
              aggregate_id: &AccountId,
              expected_version: u64,
              events: &[AccountEvent],
          ) -> AsyncIO<Result<(), EventStoreError>>
        description: |
          楽観的ロック付きイベント追加。AsyncIOで非同期実行。
        examples:
          - description: "イベントの追加（IO実行境界で実行）"
            code: |
              let io = append_events(&account_id, 5, &events);
              // IO実行境界
              io.run_async().await?;

      - name: "load_events"
        signature: |
          fn load_events(aggregate_id: &AccountId)
              -> AsyncIO<Result<PersistentList<AccountEvent>, EventStoreError>>
        description: |
          アグリゲートのイベント列を読み込み。PersistentListで返却。
        examples:
          - description: "イベントの読み込み（IO実行境界で実行）"
            code: |
              let io = load_events(&account_id);
              // IO実行境界
              let events = io.run_async().await?;

    implementations:
      - type: "PostgresEventStore"
        description: |
          PostgreSQL実装。events, snapshotsテーブルを使用。

  - id: infrastructure_messaging
    name: "メッセージング"
    description: |
      SQSベースのイベント発行。

      重要（Codexレビュー指摘対応）:
      - メッセージの構築は純粋計算で行う
      - 実際の送信はIO実行境界で行う
      - PersistentDequeは使用しない（外部SQSを直接使用）

    methods:
      - name: "build_sqs_messages"
        signature: |
          fn build_sqs_messages(events: &[AccountEvent]) -> Vec<SqsMessage>
        description: |
          イベントからSQSメッセージを構築する純粋関数。
          送信は行わない。
        examples:
          - description: "メッセージ構築（純粋計算）"
            code: |
              let messages = build_sqs_messages(&events);

      - name: "send_sqs_messages"
        signature: |
          fn send_sqs_messages(messages: &[SqsMessage])
              -> AsyncIO<Result<(), SqsError>>
        description: |
          SQSメッセージを送信するIO操作。
        examples:
          - description: "メッセージ送信（IO実行境界）"
            code: |
              let messages = build_sqs_messages(&events);
              // IO実行境界
              send_sqs_messages(&messages).run_async().await?;

    implementations:
      - type: "SqsPublisher"
        description: |
          SQSパブリッシャ。LocalStack対応。
      - type: "SqsConsumer"
        description: |
          SQSコンシューマ。Read Model更新用。

  # ======================================================================
  # 4. API層
  # ======================================================================
  - id: api_dto_transformation
    name: "DTO変換"
    description: |
      IsoとBifunctorを使用してDTO↔ドメインオブジェクト変換を実装。

    methods:
      - name: "deposit_request_iso"
        signature: |
          fn deposit_request_iso()
              -> impl Iso<(AccountId, DepositRequest), DepositCommand>
        description: |
          入金リクエストDTO↔コマンドのIso変換。
        examples:
          - description: "Isoによる変換"
            code: |
              let iso = deposit_request_iso();
              let command = iso.get((account_id, request));
              let (id, req) = iso.reverse_get(command);

      - name: "transform_result"
        signature: |
          fn transform_result<A, B>(result: Result<A, DomainError>)
              -> Result<B, ApiError>
          where A: Into<B>
        description: |
          Bifunctorを使用してResult両側を変換。
        examples:
          - description: "Bifunctorによるエラー変換"
            code: |
              let api_result = result.bimap(
                  |err| ApiError::from(err),
                  |val| ResponseDto::from(val),
              );

    implementations:
      - type: "DepositRequest"
        description: |
          入金リクエストDTO。amount, idempotency_keyを持つ。
      - type: "TransactionResponse"
        description: |
          取引レスポンスDTO。transaction_id, status, timestampを持つ。

  - id: api_handlers
    name: "APIハンドラ"
    description: |
      pipe_async!, for_async!を使用して非同期パイプラインを構築。

      これがIO実行境界となる。

    methods:
      - name: "deposit_handler"
        signature: |
          async fn deposit_handler(
              State(deps): State<AppDependencies>,
              Path(account_id): Path<String>,
              Json(request): Json<DepositRequest>,
          ) -> Result<Json<TransactionResponse>, ApiError>
        description: |
          pipe_async!による非同期パイプライン。
          バリデーション→変換→実行→レスポンス。

          IO実行境界: ここでAsyncIO/Writerの実行を行う。
        examples:
          - description: "pipe_async!パイプライン（IO実行境界）"
            code: |
              pipe_async!(
                  // 純粋計算: バリデーション
                  validate_deposit_request(&account_id, &request),
                  // 純粋計算: DTO変換
                  |validated| deposit_request_iso().get(validated),
                  // 純粋計算: コマンド実行（計算の構築）
                  |command| {
                      let writer = execute_deposit(command).run(&deps);
                      let (result, logs) = writer.run();
                      (result, logs)
                  },
                  // IO実行境界: ログ永続化とレスポンス
                  |(result, logs)| async move {
                      persist_audit_logs(&logs).await?;
                      result.map(TransactionResponse::from)
                  }
              )

    implementations:
      - type: "AccountHandler"
        description: |
          口座関連APIハンドラ。開設、照会、入金、出金。
      - type: "TransactionHandler"
        description: |
          取引関連APIハンドラ。送金、履歴。

  - id: api_middleware
    name: "ミドルウェア"
    description: |
      エラーハンドリングと監査ログを実装。

      注意: Writerで収集したログの永続化はIO実行境界で行う。

    methods:
      - name: "error_handler"
        signature: |
          async fn error_handler<B>(
              result: Result<B, DomainError>
          ) -> Result<Json<B>, ApiError>
        description: |
          ドメインエラーをAPIエラーに変換。
        examples:
          - description: "エラーハンドリング"
            code: |
              let api_result = error_handler(domain_result)?;

    implementations:
      - type: "ErrorHandlerMiddleware"
        description: |
          Axumミドルウェア。ドメインエラーをHTTPエラーに変換。

  # ======================================================================
  # 5. カスタムエフェクト（任意）
  # ======================================================================
  - id: custom_effects
    name: "カスタムエフェクト（任意）"
    description: |
      代数的エフェクトを使用してカスタムDSLを構築。

      注意: この機能は学習/デモ目的。本番では過剰な抽象化の可能性あり。

    methods:
      - name: "find_account"
        signature: |
          fn find_account<R>(account_id: &AccountId)
              -> Eff<R, Option<Account>>
          where R: Effect, DatabaseEffect<Option<Account>>: Member<R>
        description: |
          データベースエフェクトによる口座取得。
        examples:
          - description: "代数的エフェクトによるDB操作"
            code: |
              let eff = find_account(&account_id);
              // IO実行境界: インタプリタで実行
              let result = eff.run_with(postgres_interpreter).run_async().await;

    implementations:
      - type: "DatabaseEffect"
        description: |
          データベースエフェクト。Query, Execute, Transactionオペレーション。
      - type: "CacheEffect"
        description: |
          キャッシュエフェクト。Get, Set, Invalidateオペレーション。

  # ======================================================================
  # 6. 永続データ構造の活用
  # ======================================================================
  - id: persistent_data_structures
    name: "永続データ構造"
    description: |
      lambarsの永続データ構造をユースケースに適合した場面で活用する。

      Codexレビュー指摘対応:
      - PersistentDequeは使用しない（メッセージキューは外部SQSを使用）
      - 各データ構造の責務を明確にする

    implementations:
      - type: "PersistentList"
        description: |
          イベントログ。新しいイベントを先頭に追加（cons）。O(1)の追加。
          用途: イベントストアから読み込んだイベント列の保持。
      - type: "PersistentVector"
        description: |
          インデックス付き取引履歴。O(log32 N)のランダムアクセス。
          用途: ページング対応の履歴データ。
      - type: "PersistentHashMap"
        description: |
          アグリゲート状態のキャッシュ。account_id→Account。
          用途: インメモリでのアグリゲートキャッシュ。
      - type: "PersistentHashSet"
        description: |
          処理済みトランザクションIDの管理。冪等性チェック。
          用途: 重複処理防止（任意機能）。
      - type: "PersistentTreeMap"
        description: |
          時系列データ。タイムスタンプでソートされた取引履歴。
          用途: 時間範囲クエリに対応した履歴データ。

# 非機能要件
non_functional_requirements:
  performance:
    - "100,000件のイベント再生がスタックオーバーフローなしで完了すること"
    - "入金/出金APIの応答時間が100ms以内であること（ローカル環境）"
    - "Read Modelのキャッシュヒット率90%以上"
  compatibility:
    - "Rust 1.92.0以上"
    - "lambars（full feature）との互換性"
    - "PostgreSQL 16以上"
    - "Redis 7以上"
    - "LocalStack 3.0以上"
  testing:
    - "ユニットテスト: ドメイン層100%カバレッジ"
    - "統合テスト: 全APIエンドポイント"
    - "プロパティテスト: 型クラス法則検証"
    - "E2Eテスト: docker compose環境での動作確認"

# 将来の拡張
future_extensions:
  - id: graphql_api
    name: "GraphQL API"
    description: |
      async-graphqlを使用したGraphQL APIの追加。
      REST APIと並行して提供。
    rationale: |
      現時点ではREST APIの実装に集中し、GraphQLは将来の拡張とする。

  - id: saga_pattern
    name: "Sagaパターン"
    description: |
      複数アグリゲートにまたがる分散トランザクションの実装。
      補償トランザクションによるロールバック。
    rationale: |
      単一アグリゲートの実装を完了してから拡張する。

  - id: snapshot_optimization
    name: "スナップショット最適化"
    description: |
      N件ごとのスナップショット保存によるイベント再生の最適化。
    rationale: |
      基本的なイベントソーシングを実装してからパフォーマンス最適化を行う。
