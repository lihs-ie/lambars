# tasks_update エラー率測定の正確性改善 要件定義
#
# 概要:
#   tasks_update および tasks_update_conflict ベンチマークにおける
#   HTTPステータスコード分布とエラー率の測定精度を改善する
#
# 設計方針:
#   1. error_tracker.lua の既存スレッド集計機能を活用
#   2. lua_metrics.json に http_status を正確に保存
#   3. マルチスレッド環境でのステータスコード集計を確実化
#   4. run_benchmark.sh のエラー率計算ロジックを修正
#
# 参照:
#   - benches/api/benchmarks/scripts/error_tracker.lua (既存のスレッド集計実装)
#   - benches/api/benchmarks/scripts/result_collector.lua
#   - benches/api/benchmarks/scripts/tasks_update.lua
#   - docs/internal/analysis/20260202_tasks_bulk_post_integration_analysis.yaml

version: "1.0.0"
name: "tasks_update_error_rate_accuracy"
description: |
  tasks_update および tasks_update_conflict ベンチマークにおいて、
  以下の問題が発生している:

  1. **エラー率が41.4%と表示されているが、http_statusが空**
  2. **http_4xx、http_5xxがゼロ**
  3. **実際のHTTPステータスコードの分布が取得できていない**

  これにより、以下の影響が発生している:

  - エラーの内訳が不明（409 Conflict の割合が分からない）
  - リトライ戦略の効果測定が困難
  - ベンチマーク結果の信頼性が低下
  - CI/CDでのしきい値判定が不正確

  ## 問題の根本原因（Codex MCP 分析結果）

  ### 1. スレッドローカル集計の欠落

  - `result_collector.lua` の `M.status_counts` はスレッドローカル
  - wrk のマルチスレッド環境では各スレッドが独立したLua状態を持つ
  - `done()` 実行時に `M.status_counts` が空になる可能性が高い
  - 結果として `http_status` が作られず、分布が欠落

  ### 2. lua_metrics.json のマージ失敗

  - `http_status` が空の `lua_metrics.json` はマージ時にスキップされる
  - 全ファイルが無効化されるとマージ自体が失敗
  - `merge_lua_metrics.py` の厳格な検証ロジックが原因

  ### 3. run_benchmark.sh のフォールバック不足

  - `http_status` が取れない場合、`http_4xx/http_5xx` を更新できず0のまま
  - `error_rate` のみwrk由来で計算されるため「エラー率はあるがhttp_statusが空」状態
  - フォールバック順序が不適切

  ### 4. lua_metrics.json の書き込み競合（潜在的問題）

  - `done()` が各スレッドで実行される場合、書き込み先が固定で上書き競合
  - 最後のスレッドの結果だけが残る可能性

  ## 既存の実装状況

  ### 実装済み（活用すべき）

  `error_tracker.lua` には既にスレッドローカルストレージを使用した
  集計機能が実装されている:

  - `setup_thread(thread)`: 各スレッドにステータスカウンターを初期化
  - `track_thread_response(status)`: スレッドローカルストレージにカウント
  - `get_thread_aggregated_summary()`: 現在のスレッドの集計を取得

  `tasks_update.lua` では、この機能を使用してステータス分布を
  **標準出力には出力している**が、**lua_metrics.json には保存していない**。

  ### 未実装（改善が必要）

  - `result_collector.lua` が `error_tracker` の集計結果を `http_status` に反映
  - `lua_metrics.json` に正確な `http_status` を保存
  - `merge_lua_metrics.py` のフォールバック戦略

# 背景・動機
background:
  problem: |
    ## 現状の問題

    ### ベンチマーク結果の信頼性低下

    tasks_update および tasks_update_conflict のベンチマーク結果において、
    以下の矛盾が発生している:

    ```json
    {
      "results": {
        "error_rate": 0.415198,  // 41.5%のエラー率
        "http_status": {},        // HTTPステータスが空
        "retries": 0
      },
      "errors": {
        "http_4xx": 0,            // すべてゼロ
        "http_5xx": 0,
        "http_status_total": 0
      }
    }
    ```

    ### 影響範囲

    1. **リトライ戦略の効果測定が不可能**
       - 409 Conflict の割合が不明
       - リトライによる成功率の改善が測定できない
       - RETRY_COUNT の最適値が決定できない

    2. **エラー原因の特定が困難**
       - 4xx エラー（クライアント側）なのか
       - 5xx エラー（サーバー側）なのか判別不能
       - デバッグが非効率

    3. **CI/CDのしきい値判定が不正確**
       - error_rate のみで判定しているが、内訳が不明
       - 許容可能なエラー（409 Conflict）と
         致命的なエラー（500 Internal Server Error）を区別できない

    ### Codex MCP 分析結果

    読み取り専用モードでの分析により、以下の根本原因が特定された:

    1. **スレッドローカル集計の欠落**
       - `result_collector.lua:181, 256, 483`
       - `M.status_counts` がスレッド分離により空になる

    2. **lua_metrics.json のマージ失敗**
       - `merge_lua_metrics.py:184, 212`
       - `http_status` 欠落時の全スキップ

    3. **run_benchmark.sh のフォールバック不足**
       - `run_benchmark.sh:1432, 1475, 1559`
       - `http_status` が空の場合の処理が不適切

  motivation: |
    ## 実装する動機

    ### Critical な測定精度問題の解決

    tasks_update は楽観的ロック（version フィールド）を使用した
    更新エンドポイントのベンチマークであり、以下の測定が必須:

    - **409 Conflict の発生率**: 競合レベルの測定
    - **リトライ成功率**: リトライ戦略の効果測定
    - **エラー内訳**: 4xx vs 5xx の判別

    これらが測定できない現状では、ベンチマークとしての価値が大幅に低下している。

    ### 既存の実装基盤の活用

    `error_tracker.lua` には既にスレッドローカルストレージを使用した
    集計機能が実装されており、以下の対応で問題を解決可能:

    1. `result_collector.lua` が `error_tracker` の集計結果を活用
    2. `lua_metrics.json` に正確な `http_status` を保存
    3. `merge_lua_metrics.py` のフォールバック戦略を追加

    最小限の変更で最大の効果が期待できる。

    ### feature/async-io-unboxed-execution のマージブロック解除

    現在、以下のベンチマークがマージ条件を満たしていない:

    - **tasks_update**: error_rate 41.5%（目標 ≤3%）
    - **tasks_update_conflict**: error_rate 41.4%（目標 ≤10%）

    しかし、**実際のエラー率が測定できていない**ため、
    真のエラー率が不明な状態でマージ可否を判断できない。

    正確な測定により、以下のいずれかが明確になる:

    1. **実際のエラー率が低い場合**: マージ条件を満たしている
    2. **実際のエラー率が高い場合**: 追加の最適化が必要

    ### 他のベンチマークへの波及効果

    この問題は tasks_update 特有ではなく、**マルチスレッドでの
    HTTPステータス集計全般の問題**である。

    修正により、以下のベンチマークでも測定精度が向上:

    - tasks_eff
    - tasks_bulk
    - production_load
    - その他すべてのマルチスレッドベンチマーク

  prior_art:
    - name: "error_tracker.lua のスレッド集計機能"
      description: |
        benches/api/benchmarks/scripts/error_tracker.lua:154-192

        既に実装されているスレッドローカルストレージを使用した集計:

        - `setup_thread(thread)`: 各スレッドに `status_200` 等を初期化
        - `track_thread_response(status)`: `wrk.thread:set()` でカウント
        - `get_thread_aggregated_summary()`: `wrk.thread:get()` で集計取得

        tasks_update.lua では、この機能を使用してステータス分布を
        標準出力に出力している（line 308-348）が、
        lua_metrics.json には保存していない。

        **この機能を result_collector.lua で活用することで、
        最小限の変更で問題を解決できる。**

    - name: "wrk.thread のスレッドローカルストレージ"
      description: |
        wrk はスレッドローカルストレージを提供している:

        - `thread:set(key, value)`: スレッドごとの値を保存
        - `thread:get(key)`: スレッドごとの値を取得

        各スレッドは独立したLua状態を持つため、グローバル変数は
        スレッド間で共有されない。スレッドローカルストレージを
        使用することで、各スレッドの集計を `done()` 時に取得可能。

# 要件一覧
requirements:
  # ======================================================================
  # 1. result_collector.lua の改善
  # ======================================================================
  - id: REQ-ERROR-ACCURACY-001
    name: "error_tracker の集計結果を http_status に反映"
    description: |
      `result_collector.lua` の `finalize()` 関数において、
      `error_tracker.get_thread_aggregated_summary()` の結果を
      `M.results.http_status` に反映する。

      ## 設計

      ### 現在の実装（問題あり）

      ```lua
      -- result_collector.lua:483-490
      if M.results.status_distribution and type(M.results.status_distribution) == "table" and next(M.results.status_distribution) then
          for status, count in pairs(M.results.status_distribution) do
              local status_num = tonumber(status)
              if status_num and type(count) == "number" then
                  M.results.http_status[status] = count
              end
          end
      end
      ```

      `M.results.status_distribution` は `M.status_counts` から作られるが、
      スレッド分離により `M.status_counts` が空になる可能性が高い。

      ### 改善後の実装

      ```lua
      -- error_tracker が利用可能な場合、その集計結果を優先的に使用
      if error_tracker then
          local aggregated = error_tracker.get_thread_aggregated_summary()

          -- http_status を構築
          M.results.http_status = {}
          for key, count in pairs(aggregated) do
              -- "status_200" -> "200" に変換
              local status_code = key:match("^status_(.+)$")
              if status_code and status_code ~= "other" and count > 0 then
                  M.results.http_status[status_code] = count
              end
          end

          -- status_other がある場合は "other" キーで保存
          if aggregated.status_other and aggregated.status_other > 0 then
              M.results.http_status["other"] = aggregated.status_other
          end
      else
          -- error_tracker が無い場合は従来の方法
          if M.results.status_distribution and type(M.results.status_distribution) == "table" and next(M.results.status_distribution) then
              for status, count in pairs(M.results.status_distribution) do
                  local status_num = tonumber(status)
                  if status_num and type(count) == "number" then
                      M.results.http_status[status] = count
                  end
              end
          end
      end
      ```

      ### 重要な注意点

      - `error_tracker.get_thread_aggregated_summary()` は**現在のスレッドの集計のみ**を返す
      - wrk のマルチスレッド環境では、`done()` は**各スレッドで独立して実行される**
      - したがって、各スレッドの `lua_metrics.json` には**そのスレッドの集計のみ**が保存される
      - 全スレッドの集計は `merge_lua_metrics.py` で行われる

      ### 期待される効果

      - 各スレッドの `lua_metrics.json` に正確な `http_status` が保存される
      - `merge_lua_metrics.py` で全スレッドの `http_status` をマージ
      - 最終的な `meta/tasks_update.json` に正確なステータス分布が反映される

    implementations:
      - type: "result_collector.lua"
        description: |
          `finalize()` 関数の `http_status` 構築ロジックを改善。

          実装箇所: benches/api/benchmarks/scripts/result_collector.lua:483-490

          変更内容:
          1. `error_tracker` が利用可能かチェック
          2. `error_tracker.get_thread_aggregated_summary()` から集計取得
          3. "status_XXX" 形式を "XXX" に変換
          4. `M.results.http_status` に保存
          5. error_tracker が無い場合は従来の方法にフォールバック

  # ======================================================================
  # 2. merge_lua_metrics.py の改善
  # ======================================================================
  - id: REQ-ERROR-ACCURACY-002
    name: "http_status マージロジックの改善"
    description: |
      `merge_lua_metrics.py` の `http_status` マージロジックを改善し、
      一部のスレッドで `http_status` が欠落している場合でも
      正しくマージできるようにする。

      ## 設計

      ### 現在の実装（問題あり）

      ```python
      # merge_lua_metrics.py:184
      if not metrics.get("http_status"):
          print(f"WARNING: {file} has empty http_status, skipping", file=sys.stderr)
          continue
      ```

      `http_status` が空のファイルを全スキップするため、
      全ファイルが無効化されるとマージ自体が失敗する。

      ### 改善後の実装

      ```python
      # http_status が空でも他のメトリクスは活用
      if not metrics.get("http_status") or not metrics["http_status"]:
          print(f"WARNING: {file} has empty http_status, using other metrics only", file=sys.stderr)
          # http_status は空のまま、他のメトリクス（error_rate等）は集計対象
          metrics["http_status"] = {}
      ```

      ### http_status のマージロジック

      ```python
      # 各スレッドの http_status をマージ
      merged_http_status = {}
      for metrics in all_metrics:
          if "http_status" in metrics and metrics["http_status"]:
              for status, count in metrics["http_status"].items():
                  merged_http_status[status] = merged_http_status.get(status, 0) + count

      # マージ結果を最終メトリクスに設定
      if merged_http_status:
          merged["http_status"] = merged_http_status
      else:
          # 全スレッドで http_status が空の場合
          print("WARNING: All threads have empty http_status", file=sys.stderr)
          merged["http_status"] = {}
      ```

      ### error_rate の再計算

      ```python
      # http_status からエラー率を再計算
      if merged_http_status and merged.get("total_requests", 0) > 0:
          total_errors = 0
          for status, count in merged_http_status.items():
              status_num = int(status) if status.isdigit() else 0
              if status_num >= 400:
                  total_errors += count

          merged["error_rate"] = total_errors / merged["total_requests"]

          # 4xx と 5xx の内訳
          total_4xx = sum(count for status, count in merged_http_status.items()
                          if status.isdigit() and 400 <= int(status) < 500)
          total_5xx = sum(count for status, count in merged_http_status.items()
                          if status.isdigit() and 500 <= int(status) < 600)

          merged["http_4xx"] = total_4xx
          merged["http_5xx"] = total_5xx
      ```

      ### 期待される効果

      - 一部のスレッドで `http_status` が欠落してもマージが成功
      - 正確な `error_rate` を `http_status` から再計算
      - `http_4xx`、`http_5xx` を正確に集計

    implementations:
      - type: "merge_lua_metrics.py"
        description: |
          `http_status` のマージロジックを改善。

          実装箇所: benches/api/benchmarks/scripts/merge_lua_metrics.py:184, 212

          変更内容:
          1. `http_status` が空でもスキップせずに処理継続
          2. 各スレッドの `http_status` を合算
          3. `error_rate` を `http_status` から再計算
          4. `http_4xx`、`http_5xx` を集計

  # ======================================================================
  # 3. run_benchmark.sh の改善
  # ======================================================================
  - id: REQ-ERROR-ACCURACY-003
    name: "error_rate 計算のフォールバック順序改善"
    description: |
      `run_benchmark.sh` の `error_rate` 計算において、
      `http_status` から計算することを優先し、
      フォールバック順序を明確化する。

      ## 設計

      ### 現在の実装（問題あり）

      ```bash
      # run_benchmark.sh:1432
      error_rate=$(awk -v errors="${http_status_total}" -v total="${total_requests}" 'BEGIN {
          rate = errors / total
          if (rate < 0) rate = 0
          if (rate > 1) rate = 1
          printf "%.6f", rate
      }')
      ```

      `http_status_total` は wrk の `summary.errors.status` から取得されるが、
      この値は信頼性が低い（スレッド集計の問題）。

      ### 改善後の実装

      ```bash
      # フォールバック順序:
      # 1. lua_metrics.json の error_rate（http_status から計算済み）
      # 2. http_status から直接計算
      # 3. wrk の summary.errors.status から計算（最終手段）

      local error_rate=""
      local http_4xx=0
      local http_5xx=0

      # 1. lua_metrics.json の error_rate を優先
      if [[ -f "${results_base_dir}/lua_metrics.json" ]] && command -v jq &> /dev/null; then
          lua_error_rate=$(jq -r '.error_rate // empty' "${results_base_dir}/lua_metrics.json" 2>/dev/null)
          if [[ -n "${lua_error_rate}" ]]; then
              error_rate="${lua_error_rate}"
              echo -e "${CYAN}Using error_rate from lua_metrics.json: ${error_rate}${NC}"

              # http_4xx, http_5xx も取得
              http_4xx=$(jq -r '.http_4xx // 0' "${results_base_dir}/lua_metrics.json" 2>/dev/null)
              http_5xx=$(jq -r '.http_5xx // 0' "${results_base_dir}/lua_metrics.json" 2>/dev/null)
          fi
      fi

      # 2. http_status から直接計算
      if [[ -z "${error_rate}" && -f "${results_base_dir}/lua_metrics.json" ]]; then
          # http_status を読み取り、4xx と 5xx を集計
          local total_errors
          total_errors=$(jq -r '.http_status | to_entries | map(select(.key | tonumber >= 400)) | map(.value) | add // 0' "${results_base_dir}/lua_metrics.json" 2>/dev/null)

          if [[ -n "${total_errors}" && "${total_errors}" != "null" && "${total_requests}" -gt 0 ]]; then
              error_rate=$(awk -v errors="${total_errors}" -v total="${total_requests}" 'BEGIN {
                  rate = errors / total
                  if (rate < 0) rate = 0
                  if (rate > 1) rate = 1
                  printf "%.6f", rate
              }')
              echo -e "${CYAN}Calculated error_rate from http_status: ${error_rate}${NC}"

              # 4xx と 5xx を個別に集計
              http_4xx=$(jq -r '.http_status | to_entries | map(select(.key | tonumber >= 400 and tonumber < 500)) | map(.value) | add // 0' "${results_base_dir}/lua_metrics.json" 2>/dev/null)
              http_5xx=$(jq -r '.http_status | to_entries | map(select(.key | tonumber >= 500)) | map(.value) | add // 0' "${results_base_dir}/lua_metrics.json" 2>/dev/null)
          fi
      fi

      # 3. wrk の summary.errors.status から計算（最終手段）
      if [[ -z "${error_rate}" ]]; then
          error_rate=$(awk -v errors="${http_status_total}" -v total="${total_requests}" 'BEGIN {
              rate = errors / total
              if (rate < 0) rate = 0
              if (rate > 1) rate = 1
              printf "%.6f", rate
          }')
          echo -e "${YELLOW}WARNING: Using wrk-based error_rate (less accurate): ${error_rate}${NC}"
      fi
      ```

      ### 期待される効果

      - `http_status` から計算された正確な `error_rate` を使用
      - `http_4xx`、`http_5xx` を正確に集計
      - フォールバック順序が明確化

    implementations:
      - type: "run_benchmark.sh"
        description: |
          `error_rate` 計算のフォールバック順序を改善。

          実装箇所: benches/api/benchmarks/run_benchmark.sh:1432, 1475, 1559

          変更内容:
          1. lua_metrics.json の error_rate を最優先
          2. http_status から直接計算（フォールバック1）
          3. wrk の summary.errors.status から計算（フォールバック2）
          4. 各段階で警告メッセージを出力

  # ======================================================================
  # 4. 検証とテスト
  # ======================================================================
  - id: REQ-ERROR-ACCURACY-004
    name: "改善後の検証"
    description: |
      改善後、tasks_update および tasks_update_conflict ベンチマークを実行し、
      以下の項目を検証する。

      ## 検証項目

      ### 1. http_status が正確に取得できること

      ```bash
      # ベンチマーク実行
      ./run_benchmark.sh tasks_update

      # http_status を確認
      jq '.results.http_status' benches/results/tasks_update/benchmark/meta/tasks_update.json

      # 期待される出力例
      {
        "200": 14000,
        "201": 0,
        "409": 10000,
        "500": 3
      }
      ```

      ### 2. error_rate が http_status から計算されていること

      ```bash
      # error_rate と http_status の整合性を確認
      jq '{
        error_rate: .results.error_rate,
        http_status: .results.http_status,
        total_requests: .results.requests,
        calculated_error_rate: (
          (.results.http_status | to_entries | map(select(.key | tonumber >= 400)) | map(.value) | add // 0) / .results.requests
        )
      }' benches/results/tasks_update/benchmark/meta/tasks_update.json

      # error_rate と calculated_error_rate が一致すること
      ```

      ### 3. http_4xx, http_5xx が正確に集計されていること

      ```bash
      jq '{
        http_4xx: .errors.http_4xx,
        http_5xx: .errors.http_5xx,
        http_status_4xx_sum: (.results.http_status | to_entries | map(select(.key | tonumber >= 400 and tonumber < 500)) | map(.value) | add // 0),
        http_status_5xx_sum: (.results.http_status | to_entries | map(select(.key | tonumber >= 500)) | map(.value) | add // 0)
      }' benches/results/tasks_update/benchmark/meta/tasks_update.json

      # http_4xx と http_status_4xx_sum が一致すること
      # http_5xx と http_status_5xx_sum が一致すること
      ```

      ### 4. 409 Conflict の割合を確認

      ```bash
      jq '{
        total_requests: .results.requests,
        conflict_count: (.results.http_status["409"] // 0),
        conflict_rate: ((.results.http_status["409"] // 0) / .results.requests)
      }' benches/results/tasks_update/benchmark/meta/tasks_update.json

      # tasks_update_conflict では conflict_rate が高いことを確認
      ```

      ### 5. リトライ戦略の効果測定

      ```bash
      # RETRY_COUNT=0 の場合
      RETRY_COUNT=0 ./run_benchmark.sh tasks_update_conflict

      # RETRY_COUNT=3 の場合
      RETRY_COUNT=3 ./run_benchmark.sh tasks_update_conflict

      # conflict_rate の変化を比較
      # RETRY_COUNT=3 の方が conflict_rate が低いことを確認
      ```

      ## 期待される結果

      ### tasks_update

      - `error_rate`: 1-5%（409 Conflict を含む）
      - `http_status`: {"200": 19000, "409": 800, ...}
      - `http_4xx`: 800（主に409 Conflict）
      - `http_5xx`: 数件以下

      ### tasks_update_conflict

      - `error_rate`: 5-15%（409 Conflict を含む）
      - `http_status`: {"200": 12000, "409": 3000, ...}
      - `http_4xx`: 3000（主に409 Conflict）
      - `http_5xx`: 数件以下

      ### RETRY_COUNT の効果

      - RETRY_COUNT=0: conflict_rate 10-15%
      - RETRY_COUNT=3: conflict_rate 5-8%（リトライにより改善）

# 非機能要件
non_functional_requirements:
  performance:
    - "スレッドローカルストレージの読み取りオーバーヘッドは done() 時のみ（無視できる）"
    - "lua_metrics.json のマージ時間への影響は最小限（http_status のマージのみ追加）"
    - "ベンチマーク実行時間への影響なし（測定ロジックの改善のみ）"

  compatibility:
    - "既存の lua_metrics.json フォーマットとの互換性維持"
    - "error_tracker が無い環境でも動作（フォールバック）"
    - "result_collector.lua の公開APIは変更なし"
    - "merge_lua_metrics.py のコマンドライン引数は変更なし"

  testing:
    - "tasks_update ベンチマークで http_status が正確に取得できることを確認"
    - "tasks_update_conflict ベンチマークで http_status が正確に取得できることを確認"
    - "error_rate と http_status の整合性を検証"
    - "http_4xx, http_5xx と http_status の整合性を検証"
    - "RETRY_COUNT の効果測定が可能であることを確認"
    - "マルチスレッド環境（threads=4, 8等）での動作確認"

# 実装計画
implementation_plan:
  phase_1_result_collector:
    - id: "IMPL-001"
      title: "result_collector.lua の改善"
      estimated_effort: "0.5 days"
      tasks:
        - "finalize() 関数で error_tracker.get_thread_aggregated_summary() を使用"
        - "http_status の構築ロジックを追加"
        - "error_tracker が無い場合のフォールバック"
        - "ユニットテスト（手動確認）"

  phase_2_merge_lua_metrics:
    - id: "IMPL-002"
      title: "merge_lua_metrics.py の改善"
      estimated_effort: "1 day"
      tasks:
        - "http_status が空でもスキップしない"
        - "http_status のマージロジックを追加"
        - "error_rate の再計算ロジックを追加"
        - "http_4xx, http_5xx の集計ロジックを追加"
        - "ユニットテスト（Python）"

  phase_3_run_benchmark:
    - id: "IMPL-003"
      title: "run_benchmark.sh の改善"
      estimated_effort: "0.5 days"
      tasks:
        - "error_rate 計算のフォールバック順序を改善"
        - "http_4xx, http_5xx の読み取りロジックを追加"
        - "警告メッセージの追加"
        - "統合テスト（tasks_update）"

  phase_4_validation:
    - id: "IMPL-004"
      title: "検証とテスト"
      estimated_effort: "1 day"
      tasks:
        - "tasks_update ベンチマークの実行と検証"
        - "tasks_update_conflict ベンチマークの実行と検証"
        - "http_status の正確性を確認"
        - "error_rate の整合性を確認"
        - "RETRY_COUNT の効果測定"
        - "ドキュメント更新"

# 受け入れ基準
acceptance_criteria:
  minimum:
    - "result_collector.lua が error_tracker の集計結果を http_status に反映"
    - "merge_lua_metrics.py が http_status を正確にマージ"
    - "run_benchmark.sh が http_status から error_rate を計算"
    - "tasks_update で http_status が空でないこと"
    - "error_rate と http_status の整合性が取れていること"

  recommended:
    - "http_4xx, http_5xx が正確に集計されていること"
    - "409 Conflict の割合が測定できること"
    - "RETRY_COUNT の効果が測定できること"
    - "マルチスレッド環境（threads=4, 8）で動作すること"

  stretch:
    - "全ベンチマークで http_status が正確に取得できること"
    - "CI/CD でのしきい値判定が正確になること"
    - "エラー原因の分析が容易になること"

# 将来の拡張
future_extensions:
  - id: "EXT-001"
    name: "スレッドごとの lua_metrics.json 出力"
    description: |
      現在、各スレッドの `done()` が同じファイルに書き込むため、
      上書き競合の可能性がある。

      将来的には、以下の設計を検討:

      1. `LUA_RESULTS_DIR` に `thread_<thread_id>` ディレクトリを作成
      2. 各スレッドが `thread_<thread_id>/lua_metrics.json` に書き込み
      3. `merge_lua_metrics.py` が全スレッドのファイルをマージ

      これにより、スレッドごとの詳細な分析も可能になる。

    rationale: |
      現時点では、`error_tracker` のスレッド集計機能により
      最低限の精度が確保されるため、優先度は低い。

      スレッドごとの詳細な分析が必要になった場合に実装する。

  - id: "EXT-002"
    name: "リアルタイムエラー率モニタリング"
    description: |
      ベンチマーク実行中に、リアルタイムでエラー率を表示する機能。

      実装例:
      - 5秒ごとに error_rate を計算
      - しきい値を超えた場合は警告を表示
      - 早期に問題を検出して中断可能

    rationale: |
      現時点では、ベンチマーク終了後の分析で十分。

      長時間実行するベンチマークで必要になった場合に実装する。

# 関連ドキュメント
related_documents:
  requirements:
    - path: "docs/internal/requirements/20260202_0930_tasks_bulk_hashset_bulk_optimization.yaml"
      description: "tasks_bulk の最適化要件定義（参考）"

  analysis:
    - path: "docs/internal/analysis/20260202_tasks_bulk_post_integration_analysis.yaml"
      description: "tasks_bulk の分析レポート（参考）"

  evidence:
    - path: "benches/results/feature-async-io-unboxed-execution/tasks_update/"
      description: "tasks_update ベンチマーク結果"

    - path: "benches/results/feature-async-io-unboxed-execution/tasks_update_conflict/"
      description: "tasks_update_conflict ベンチマーク結果"

# メタ情報
metadata:
  created_at: "2026-02-04T14:00:00Z"
  created_by: "Claude Code"
  codex_reviewed: false
  status: "completed"
  priority: "P0"
  blocking_merge: false
  estimated_effort: "3 days"
  actual_effort: "2 days"
  target_branch: "feature/async-io-unboxed-execution"
  completed_at: "2026-02-04T15:30:00Z"
  implementation_commits:
    - "1ebc1f5: feat(benches): implement HTTP status collection pipeline"
    - "c2939cc: fix(benches): improve tasks_update error rate measurement accuracy"
    - "c707c08: fix(benches): tasks_update エラー率改善"
  notes: |
    Codex MCP 分析により、以下の根本原因が特定された:

    1. result_collector.lua のスレッドローカル集計の欠落
    2. merge_lua_metrics.py の http_status マージ失敗
    3. run_benchmark.sh のフォールバック不足

    既存の error_tracker.lua のスレッド集計機能を活用することで、
    最小限の変更で問題を解決可能。

    この修正により、tasks_update および tasks_update_conflict の
    真のエラー率が測定可能になり、feature/async-io-unboxed-execution の
    マージ可否を正確に判断できる。

    ## 実装結果

    ### 完了した項目

    1. **result_collector.lua の改善**
       - error_tracker の集計結果を http_status に反映
       - error_tracker が無い場合のフォールバック実装

    2. **merge_lua_metrics.py の改善**
       - http_status が空でもスキップしない
       - http_status のマージロジック追加
       - error_rate の再計算ロジック追加

    3. **run_benchmark.sh の改善**
       - error_rate 計算のフォールバック順序改善
       - http_4xx, http_5xx の読み取りロジック追加

    ### 検証結果

    - tasks_update で http_status が正確に取得できることを確認
    - error_rate と http_status の整合性を検証
    - マルチスレッド環境での動作を確認

    ### 受け入れ基準の達成状況

    - [x] result_collector.lua が error_tracker の集計結果を http_status に反映
    - [x] merge_lua_metrics.py が http_status を正確にマージ
    - [x] run_benchmark.sh が http_status から error_rate を計算
    - [x] tasks_update で http_status が空でないこと
    - [x] error_rate と http_status の整合性が取れていること
