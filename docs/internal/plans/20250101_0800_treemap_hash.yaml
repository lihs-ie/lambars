# Phase 9.3: PersistentTreeMap<K, V> への Hash トレイト追加 - 実装計画
# rust-implementation-reviewer が要件定義 (phase_9_3_treemap_hash.yaml) に基づいて作成

version: "1.0.0"
created_at: "2026-01-02"
phase_id: phase_9_3
requirements_reference: docs/phase_9_requirements/phase_9_3_treemap_hash.yaml

# =============================================================================
# 実装方針
# =============================================================================

implementation_approach:
  methodology: TDD (Test-Driven Development)
  test_first: true
  coverage_target: 100%

  principles:
    - テストを先に書き、レッドからグリーンへ
    - 各要件を小さな単位に分割して段階的に実装
    - 既存の PartialEq/Eq 実装パターンを踏襲
    - "#![forbid(unsafe_code)] ポリシーを維持"
    - Hash と Eq の一貫性を常に保証

  coding_conventions:
    - 変数名・関数名は略語を使用しない（URL, UUID, ULID 等の共通認識のあるもの以外）
    - 既存の PersistentTreeMap 実装パターンを踏襲
    - ドキュメントコメントは英語で記載
    - テストは日本語コメントで説明可能

  key_implementation_notes:
    - PersistentTreeMap は順序付きマップ（赤黒木ベース）であるため、iter() はキー順でエントリを返す
    - (key, value) ペアをキー順でハッシュすることで、挿入順序に依存しないハッシュ値を保証
    - K: Clone + Ord + Hash, V: Clone + Hash の制約が必要

# =============================================================================
# ファイル構成
# =============================================================================

file_structure:
  source_files:
    - path: src/persistent/treemap.rs
      description: Hash トレイト実装の追加
      requirements:
        - FR-001
        - FR-002
        - FR-003
      modification_type: append
      estimated_lines_added: 20-25
      changes:
        - "use std::hash::{Hash, Hasher}; を既存の use 文に追加"
        - "impl<K, V> Hash for PersistentTreeMap<K, V> where K: Clone + Ord + Hash, V: Clone + Hash の追加"

  test_files:
    - path: tests/persistent_treemap_tests.rs
      description: Hash 関連ユニットテストの追加
      modification_type: append
      estimated_lines_added: 100-120

    - path: tests/persistent_treemap_laws.rs
      description: Hash 法則のプロパティベーステストの追加
      modification_type: append
      estimated_lines_added: 50-70

# =============================================================================
# 実装順序（TDD サイクル）
# =============================================================================

implementation_order:

  # ---------------------------------------------------------------------------
  # Step 1: RED - 基本ハッシュテスト作成
  # ---------------------------------------------------------------------------
  - step: 1
    name: 基本ハッシュテスト作成（RED）
    phase: red
    description: |
      Hash トレイトが実装されていることを確認する基本テストを作成。
      この時点ではコンパイルエラーとなる。
    files:
      - tests/persistent_treemap_tests.rs

    tasks:
      - id: 1.1
        description: |
          テスト作成: 空マップがハッシュ可能であること
        test_first: true
        test_code: |
          // =============================================================================
          // Hash トレイト テスト
          // =============================================================================

          mod hash_tests {
              use super::*;
              use std::collections::hash_map::DefaultHasher;
              use std::hash::{Hash, Hasher};

              /// 空マップがハッシュ可能であることを確認
              #[rstest]
              fn test_empty_treemap_hash() {
                  let empty: PersistentTreeMap<i32, String> = PersistentTreeMap::new();
                  let mut hasher = DefaultHasher::new();
                  empty.hash(&mut hasher);
                  let _hash_value = hasher.finish();
                  // ハッシュ値が計算できれば成功
              }
          }

      - id: 1.2
        description: |
          テスト作成: 単一エントリマップがハッシュ可能であること
        test_first: true
        test_code: |
              /// 単一エントリマップがハッシュ可能であることを確認
              #[rstest]
              fn test_singleton_treemap_hash() {
                  let map = PersistentTreeMap::singleton(42, "answer".to_string());
                  let mut hasher = DefaultHasher::new();
                  map.hash(&mut hasher);
                  let _hash_value = hasher.finish();
              }

      - id: 1.3
        description: |
          テスト作成: 複数エントリマップがハッシュ可能であること
        test_first: true
        test_code: |
              /// 複数エントリマップがハッシュ可能であることを確認
              #[rstest]
              fn test_multi_entry_treemap_hash() {
                  let map = PersistentTreeMap::new()
                      .insert(1, "one".to_string())
                      .insert(2, "two".to_string())
                      .insert(3, "three".to_string());
                  let mut hasher = DefaultHasher::new();
                  map.hash(&mut hasher);
                  let _hash_value = hasher.finish();
              }

    expected_result: |
      テストはコンパイルエラーとなる。
      "the trait `Hash` is not implemented for `PersistentTreeMap<i32, String>`"

  # ---------------------------------------------------------------------------
  # Step 2: GREEN - Hash トレイト実装
  # ---------------------------------------------------------------------------
  - step: 2
    name: Hash トレイト実装（GREEN）
    phase: green
    description: |
      PersistentTreeMap に Hash トレイトを実装し、Step 1 のテストを通過させる。
    files:
      - src/persistent/treemap.rs

    tasks:
      - id: 2.1
        description: |
          use 文に Hash, Hasher を追加
        implementation: |
          // src/persistent/treemap.rs の先頭付近（既存の use std::fmt; の下）に追加
          use std::hash::{Hash, Hasher};

      - id: 2.2
        description: |
          Hash トレイト実装を追加
          位置: Eq 実装の直後（line 1075 の後）
        implementation: |
          impl<K, V> Hash for PersistentTreeMap<K, V>
          where
              K: Clone + Ord + Hash,
              V: Clone + Hash,
          {
              fn hash<H: Hasher>(&self, state: &mut H) {
                  // 長さをハッシュすることで、異なるサイズのマップを区別
                  self.length.hash(state);
                  // 各エントリをキー順でハッシュ（iter() はキー順で返す）
                  for (key, value) in self.iter() {
                      key.hash(state);
                      value.hash(state);
                  }
              }
          }

    expected_result: |
      Step 1 で作成した基本テストが全て通過する。
      cargo test --features persistent hash_tests

  # ---------------------------------------------------------------------------
  # Step 3: RED - Hash-Eq 一貫性テスト作成
  # ---------------------------------------------------------------------------
  - step: 3
    name: Hash-Eq 一貫性テスト作成（RED）
    phase: red
    description: |
      Hash と Eq の一貫性（等しいマップは同じハッシュ値を持つ）を検証するテストを作成。
    files:
      - tests/persistent_treemap_tests.rs

    tasks:
      - id: 3.1
        description: |
          テスト作成: 等しいマップは同じハッシュ値を持つ
        test_first: true
        test_code: |
              /// 等しいマップは同じハッシュ値を持つことを確認（Hash-Eq 一貫性）
              #[rstest]
              fn test_equal_treemaps_same_hash() {
                  let map1 = PersistentTreeMap::new()
                      .insert(1, "one".to_string())
                      .insert(2, "two".to_string());
                  let map2 = PersistentTreeMap::new()
                      .insert(1, "one".to_string())
                      .insert(2, "two".to_string());
                  assert_eq!(map1, map2);

                  let mut hasher1 = DefaultHasher::new();
                  let mut hasher2 = DefaultHasher::new();
                  map1.hash(&mut hasher1);
                  map2.hash(&mut hasher2);
                  assert_eq!(hasher1.finish(), hasher2.finish());
              }

      - id: 3.2
        description: |
          テスト作成: 挿入順序が異なっても等しいマップは同じハッシュ値を持つ
        test_first: true
        test_code: |
              /// 挿入順序が異なっても等しいマップは同じハッシュ値を持つことを確認
              #[rstest]
              fn test_different_insert_order_same_hash() {
                  let map1 = PersistentTreeMap::new()
                      .insert(1, "one".to_string())
                      .insert(2, "two".to_string())
                      .insert(3, "three".to_string());
                  let map2 = PersistentTreeMap::new()
                      .insert(3, "three".to_string())
                      .insert(1, "one".to_string())
                      .insert(2, "two".to_string());
                  assert_eq!(map1, map2);

                  let mut hasher1 = DefaultHasher::new();
                  let mut hasher2 = DefaultHasher::new();
                  map1.hash(&mut hasher1);
                  map2.hash(&mut hasher2);
                  assert_eq!(hasher1.finish(), hasher2.finish());
              }

      - id: 3.3
        description: |
          テスト作成: 異なるマップは（高確率で）異なるハッシュ値を持つ
        test_first: true
        test_code: |
              /// 異なるマップは高確率で異なるハッシュ値を持つことを確認
              #[rstest]
              fn test_different_treemaps_likely_different_hash() {
                  let map1 = PersistentTreeMap::new()
                      .insert(1, "one".to_string());
                  let map2 = PersistentTreeMap::new()
                      .insert(1, "ONE".to_string());
                  assert_ne!(map1, map2);

                  let mut hasher1 = DefaultHasher::new();
                  let mut hasher2 = DefaultHasher::new();
                  map1.hash(&mut hasher1);
                  map2.hash(&mut hasher2);
                  // 衝突の可能性はあるが、この例では異なるはず
                  assert_ne!(hasher1.finish(), hasher2.finish());
              }

      - id: 3.4
        description: |
          テスト作成: 異なるキーを持つマップは異なるハッシュ値を持つ
        test_first: true
        test_code: |
              /// 異なるキーを持つマップは異なるハッシュ値を持つことを確認
              #[rstest]
              fn test_different_keys_different_hash() {
                  let map1 = PersistentTreeMap::new()
                      .insert(1, "value".to_string());
                  let map2 = PersistentTreeMap::new()
                      .insert(2, "value".to_string());

                  let mut hasher1 = DefaultHasher::new();
                  let mut hasher2 = DefaultHasher::new();
                  map1.hash(&mut hasher1);
                  map2.hash(&mut hasher2);
                  assert_ne!(hasher1.finish(), hasher2.finish());
              }

      - id: 3.5
        description: |
          テスト作成: 異なるサイズのマップは異なるハッシュ値を持つ
        test_first: true
        test_code: |
              /// 異なるサイズのマップは異なるハッシュ値を持つことを確認
              #[rstest]
              fn test_different_size_different_hash() {
                  let map1 = PersistentTreeMap::new()
                      .insert(1, "one".to_string());
                  let map2 = PersistentTreeMap::new()
                      .insert(1, "one".to_string())
                      .insert(2, "two".to_string());

                  let mut hasher1 = DefaultHasher::new();
                  let mut hasher2 = DefaultHasher::new();
                  map1.hash(&mut hasher1);
                  map2.hash(&mut hasher2);
                  assert_ne!(hasher1.finish(), hasher2.finish());
              }

      - id: 3.6
        description: |
          テスト作成: 同じマップに対するハッシュは決定的である
        test_first: true
        test_code: |
              /// 同じマップに対するハッシュは決定的であることを確認
              #[rstest]
              fn test_hash_deterministic() {
                  let map = PersistentTreeMap::new()
                      .insert(1, "one".to_string())
                      .insert(2, "two".to_string())
                      .insert(3, "three".to_string());

                  let mut hasher1 = DefaultHasher::new();
                  let mut hasher2 = DefaultHasher::new();
                  map.hash(&mut hasher1);
                  map.hash(&mut hasher2);
                  assert_eq!(hasher1.finish(), hasher2.finish());
              }

    expected_result: |
      テストは全て通過する（Step 2 で実装済みのため）。
      もし失敗する場合は、実装を修正して GREEN に戻す。

  # ---------------------------------------------------------------------------
  # Step 4: RED - コレクション使用テスト作成
  # ---------------------------------------------------------------------------
  - step: 4
    name: コレクション使用テスト作成（RED）
    phase: red
    description: |
      HashMap/HashSet で PersistentTreeMap を使用できることを検証するテストを作成。
    files:
      - tests/persistent_treemap_tests.rs

    tasks:
      - id: 4.1
        description: |
          テスト作成: HashMap のキーとして使用可能
        test_first: true
        test_code: |
              /// HashMap のキーとして使用可能であることを確認
              #[rstest]
              fn test_hashmap_key() {
                  use std::collections::HashMap;

                  let mut map: HashMap<PersistentTreeMap<i32, String>, &str> = HashMap::new();
                  let key1 = PersistentTreeMap::new()
                      .insert(1, "one".to_string());
                  let key2 = PersistentTreeMap::new()
                      .insert(2, "two".to_string());

                  map.insert(key1.clone(), "first");
                  map.insert(key2.clone(), "second");

                  assert_eq!(map.get(&key1), Some(&"first"));
                  assert_eq!(map.get(&key2), Some(&"second"));
                  // 同じエントリを持つ新しいマップでも取得可能
                  let key1_copy = PersistentTreeMap::new()
                      .insert(1, "one".to_string());
                  assert_eq!(map.get(&key1_copy), Some(&"first"));
              }

      - id: 4.2
        description: |
          テスト作成: HashSet の要素として使用可能
        test_first: true
        test_code: |
              /// HashSet の要素として使用可能であることを確認
              #[rstest]
              fn test_hashset_element() {
                  use std::collections::HashSet;

                  let mut set: HashSet<PersistentTreeMap<i32, String>> = HashSet::new();
                  set.insert(PersistentTreeMap::new().insert(1, "one".to_string()));
                  set.insert(PersistentTreeMap::new().insert(2, "two".to_string()));
                  set.insert(PersistentTreeMap::new().insert(1, "one".to_string())); // 重複

                  assert_eq!(set.len(), 2);
                  assert!(set.contains(&PersistentTreeMap::new().insert(1, "one".to_string())));
                  assert!(set.contains(&PersistentTreeMap::new().insert(2, "two".to_string())));
                  assert!(!set.contains(&PersistentTreeMap::new().insert(3, "three".to_string())));
              }

      - id: 4.3
        description: |
          テスト作成: PersistentHashSet の要素として使用可能
        test_first: true
        test_code: |
              /// PersistentHashSet の要素として使用可能であることを確認
              #[rstest]
              fn test_persistent_hashset_element() {
                  use lambars::persistent::PersistentHashSet;

                  let treemap1 = PersistentTreeMap::new()
                      .insert(1, "one".to_string());
                  let treemap2 = PersistentTreeMap::new()
                      .insert(2, "two".to_string());

                  let set = PersistentHashSet::new()
                      .insert(treemap1.clone())
                      .insert(treemap2.clone());

                  assert!(set.contains(&treemap1));
                  assert!(set.contains(&treemap2));
              }

      - id: 4.4
        description: |
          テスト作成: PersistentHashMap のキーとして使用可能
        test_first: true
        test_code: |
              /// PersistentHashMap のキーとして使用可能であることを確認
              #[rstest]
              fn test_persistent_hashmap_key() {
                  use lambars::persistent::PersistentHashMap;

                  let key1 = PersistentTreeMap::new()
                      .insert(1, "one".to_string());
                  let key2 = PersistentTreeMap::new()
                      .insert(2, "two".to_string());

                  let map = PersistentHashMap::new()
                      .insert(key1.clone(), "first")
                      .insert(key2.clone(), "second");

                  assert_eq!(map.get(&key1), Some(&"first"));
                  assert_eq!(map.get(&key2), Some(&"second"));
              }

    expected_result: |
      テストは全て通過する（Step 2 で実装済みのため）。

  # ---------------------------------------------------------------------------
  # Step 5: RED - ネストしたマップのハッシュテスト
  # ---------------------------------------------------------------------------
  - step: 5
    name: ネストしたマップのハッシュテスト（RED）
    phase: red
    description: |
      PersistentTreeMap<K, PersistentTreeMap<K, V>> や
      PersistentTreeMap<K, PersistentList<V>> のハッシュが正しく動作することを検証。
    files:
      - tests/persistent_treemap_tests.rs

    tasks:
      - id: 5.1
        description: |
          テスト作成: ネストしたマップのハッシュ
        test_first: true
        test_code: |
              /// ネストしたマップのハッシュが正しく動作することを確認
              #[rstest]
              fn test_nested_treemap_hash() {
                  let inner1 = PersistentTreeMap::new()
                      .insert(1, 10)
                      .insert(2, 20);
                  let inner2 = PersistentTreeMap::new()
                      .insert(3, 30)
                      .insert(4, 40);

                  let nested1: PersistentTreeMap<&str, PersistentTreeMap<i32, i32>> =
                      PersistentTreeMap::new()
                          .insert("first", inner1.clone())
                          .insert("second", inner2.clone());
                  let nested2: PersistentTreeMap<&str, PersistentTreeMap<i32, i32>> =
                      PersistentTreeMap::new()
                          .insert("first", inner1)
                          .insert("second", inner2);

                  // 同じ構造のネストしたマップは同じハッシュ値を持つ
                  let mut hasher1 = DefaultHasher::new();
                  let mut hasher2 = DefaultHasher::new();
                  nested1.hash(&mut hasher1);
                  nested2.hash(&mut hasher2);
                  assert_eq!(hasher1.finish(), hasher2.finish());
              }

      - id: 5.2
        description: |
          テスト作成: PersistentList を値に持つマップのハッシュ
        test_first: true
        test_code: |
              /// PersistentList を値に持つマップのハッシュが正しく動作することを確認
              #[rstest]
              fn test_treemap_with_persistent_list_values() {
                  use lambars::persistent::PersistentList;

                  let list1: PersistentList<i32> = (1..=3).collect();
                  let list2: PersistentList<i32> = (4..=6).collect();

                  let map1: PersistentTreeMap<&str, PersistentList<i32>> =
                      PersistentTreeMap::new()
                          .insert("first", list1.clone())
                          .insert("second", list2.clone());
                  let map2: PersistentTreeMap<&str, PersistentList<i32>> =
                      PersistentTreeMap::new()
                          .insert("first", list1)
                          .insert("second", list2);

                  let mut hasher1 = DefaultHasher::new();
                  let mut hasher2 = DefaultHasher::new();
                  map1.hash(&mut hasher1);
                  map2.hash(&mut hasher2);
                  assert_eq!(hasher1.finish(), hasher2.finish());
              }

      - id: 5.3
        description: |
          テスト作成: ネストしたマップの HashSet での使用
        test_first: true
        test_code: |
              /// ネストしたマップを HashSet で使用できることを確認
              #[rstest]
              fn test_nested_treemap_in_hashset() {
                  use std::collections::HashSet;

                  let inner1 = PersistentTreeMap::new()
                      .insert(1, 10);
                  let inner2 = PersistentTreeMap::new()
                      .insert(2, 20);

                  let nested1: PersistentTreeMap<&str, PersistentTreeMap<i32, i32>> =
                      PersistentTreeMap::new()
                          .insert("key", inner1);
                  let nested2: PersistentTreeMap<&str, PersistentTreeMap<i32, i32>> =
                      PersistentTreeMap::new()
                          .insert("key", inner2);

                  let mut set: HashSet<PersistentTreeMap<&str, PersistentTreeMap<i32, i32>>> =
                      HashSet::new();
                  set.insert(nested1.clone());
                  set.insert(nested2.clone());

                  // 内部の値が異なるので2つの異なる要素として扱われる
                  assert_eq!(set.len(), 2);
              }

    expected_result: |
      テストは全て通過する。

  # ---------------------------------------------------------------------------
  # Step 6: RED - プロパティベーステスト作成
  # ---------------------------------------------------------------------------
  - step: 6
    name: プロパティベーステスト作成（RED）
    phase: red
    description: |
      Hash 法則をプロパティベーステストで検証する。
    files:
      - tests/persistent_treemap_laws.rs

    tasks:
      - id: 6.1
        description: |
          プロパティテスト: Hash-Eq 一貫性
        test_first: true
        test_code: |
          // =============================================================================
          // Hash Laws
          // =============================================================================

          use std::collections::hash_map::DefaultHasher;
          use std::hash::{Hash, Hasher};

          /// ヘルパー関数: マップのハッシュ値を計算
          fn calculate_hash<T: Hash>(value: &T) -> u64 {
              let mut hasher = DefaultHasher::new();
              value.hash(&mut hasher);
              hasher.finish()
          }

          proptest! {
              /// Hash-Eq 一貫性: a == b ならば hash(a) == hash(b)
              #[test]
              fn prop_hash_eq_consistency(
                  entries in prop::collection::vec((any::<i32>(), any::<i32>()), 0..50)
              ) {
                  let map1: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();
                  let map2: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();

                  prop_assert_eq!(map1, map2);
                  prop_assert_eq!(calculate_hash(&map1), calculate_hash(&map2));
              }
          }

      - id: 6.2
        description: |
          プロパティテスト: ハッシュの決定性
        test_first: true
        test_code: |
          proptest! {
              /// ハッシュの決定性: 同じマップは常に同じハッシュ値を持つ
              #[test]
              fn prop_hash_deterministic(
                  entries in prop::collection::vec((any::<i32>(), any::<i32>()), 0..50)
              ) {
                  let map: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();

                  let hash1 = calculate_hash(&map);
                  let hash2 = calculate_hash(&map);

                  prop_assert_eq!(hash1, hash2);
              }
          }

      - id: 6.3
        description: |
          プロパティテスト: 挿入順序に依存しないハッシュ値
        test_first: true
        test_code: |
          proptest! {
              /// 挿入順序に依存しないハッシュ値
              #[test]
              fn prop_hash_insert_order_independent(
                  entries in prop::collection::vec((any::<i32>(), any::<i32>()), 2..20)
              ) {
                  use rand::seq::SliceRandom;
                  use rand::thread_rng;

                  let map1: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();

                  let mut shuffled = entries.clone();
                  shuffled.shuffle(&mut thread_rng());
                  let map2: PersistentTreeMap<i32, i32> = shuffled.iter().cloned().collect();

                  // 同じキーに対する最後の値が使われるため、結果は同じ
                  prop_assert_eq!(map1, map2);
                  prop_assert_eq!(calculate_hash(&map1), calculate_hash(&map2));
              }
          }

      - id: 6.4
        description: |
          プロパティテスト: clone したマップは同じハッシュ値を持つ
        test_first: true
        test_code: |
          proptest! {
              /// clone したマップは同じハッシュ値を持つ
              #[test]
              fn prop_hash_clone_consistency(
                  entries in prop::collection::vec((any::<i32>(), any::<i32>()), 0..50)
              ) {
                  let map: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();
                  let cloned = map.clone();

                  prop_assert_eq!(calculate_hash(&map), calculate_hash(&cloned));
              }
          }

    expected_result: |
      プロパティテストは全て通過する。

  # ---------------------------------------------------------------------------
  # Step 7: REFACTOR - コードの整理
  # ---------------------------------------------------------------------------
  - step: 7
    name: リファクタリング（REFACTOR）
    phase: refactor
    description: |
      実装とテストの整理。ドキュメントコメントの追加。
    files:
      - src/persistent/treemap.rs

    tasks:
      - id: 7.1
        description: |
          Hash トレイト実装にドキュメントコメントを追加
        implementation: |
          /// Computes a hash value for this tree map.
          ///
          /// The hash is computed by first hashing the length, then hashing each
          /// (key, value) pair in key order. This ensures that:
          ///
          /// - Maps with different sizes have different hashes (with high probability)
          /// - The insertion order does not affect the hash value (since iteration is in key order)
          /// - Equal maps produce equal hash values (Hash-Eq consistency)
          ///
          /// # Examples
          ///
          /// ```rust
          /// use lambars::persistent::PersistentTreeMap;
          /// use std::collections::HashMap;
          ///
          /// let mut outer: HashMap<PersistentTreeMap<i32, String>, &str> = HashMap::new();
          /// let key = PersistentTreeMap::new()
          ///     .insert(1, "one".to_string())
          ///     .insert(2, "two".to_string());
          /// outer.insert(key.clone(), "value");
          /// assert_eq!(outer.get(&key), Some(&"value"));
          /// ```
          impl<K, V> Hash for PersistentTreeMap<K, V>
          where
              K: Clone + Ord + Hash,
              V: Clone + Hash,
          {
              fn hash<H: Hasher>(&self, state: &mut H) {
                  self.length.hash(state);
                  for (key, value) in self.iter() {
                      key.hash(state);
                      value.hash(state);
                  }
              }
          }

      - id: 7.2
        description: |
          テストの整理とグループ化の確認

    expected_result: |
      全てのテストが通過し、ドキュメントが完備している。

# =============================================================================
# テストファイル完全版
# =============================================================================

test_files_complete:

  persistent_treemap_tests.rs:
    location: tests/persistent_treemap_tests.rs
    section_to_add: |
      // =============================================================================
      // Hash トレイト テスト
      // =============================================================================

      mod hash_tests {
          use super::*;
          use std::collections::hash_map::DefaultHasher;
          use std::hash::{Hash, Hasher};

          // -------------------------------------------------------------------------
          // 基本ハッシュテスト
          // -------------------------------------------------------------------------

          /// 空マップがハッシュ可能であることを確認
          #[rstest]
          fn test_empty_treemap_hash() {
              let empty: PersistentTreeMap<i32, String> = PersistentTreeMap::new();
              let mut hasher = DefaultHasher::new();
              empty.hash(&mut hasher);
              let _hash_value = hasher.finish();
          }

          /// 単一エントリマップがハッシュ可能であることを確認
          #[rstest]
          fn test_singleton_treemap_hash() {
              let map = PersistentTreeMap::singleton(42, "answer".to_string());
              let mut hasher = DefaultHasher::new();
              map.hash(&mut hasher);
              let _hash_value = hasher.finish();
          }

          /// 複数エントリマップがハッシュ可能であることを確認
          #[rstest]
          fn test_multi_entry_treemap_hash() {
              let map = PersistentTreeMap::new()
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string())
                  .insert(3, "three".to_string());
              let mut hasher = DefaultHasher::new();
              map.hash(&mut hasher);
              let _hash_value = hasher.finish();
          }

          // -------------------------------------------------------------------------
          // Hash-Eq 一貫性テスト
          // -------------------------------------------------------------------------

          /// 等しいマップは同じハッシュ値を持つことを確認（Hash-Eq 一貫性）
          #[rstest]
          fn test_equal_treemaps_same_hash() {
              let map1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string());
              let map2 = PersistentTreeMap::new()
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string());
              assert_eq!(map1, map2);

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              map1.hash(&mut hasher1);
              map2.hash(&mut hasher2);
              assert_eq!(hasher1.finish(), hasher2.finish());
          }

          /// 挿入順序が異なっても等しいマップは同じハッシュ値を持つことを確認
          #[rstest]
          fn test_different_insert_order_same_hash() {
              let map1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string())
                  .insert(3, "three".to_string());
              let map2 = PersistentTreeMap::new()
                  .insert(3, "three".to_string())
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string());
              assert_eq!(map1, map2);

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              map1.hash(&mut hasher1);
              map2.hash(&mut hasher2);
              assert_eq!(hasher1.finish(), hasher2.finish());
          }

          /// 異なるマップは高確率で異なるハッシュ値を持つことを確認
          #[rstest]
          fn test_different_treemaps_likely_different_hash() {
              let map1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string());
              let map2 = PersistentTreeMap::new()
                  .insert(1, "ONE".to_string());
              assert_ne!(map1, map2);

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              map1.hash(&mut hasher1);
              map2.hash(&mut hasher2);
              assert_ne!(hasher1.finish(), hasher2.finish());
          }

          /// 異なるキーを持つマップは異なるハッシュ値を持つことを確認
          #[rstest]
          fn test_different_keys_different_hash() {
              let map1 = PersistentTreeMap::new()
                  .insert(1, "value".to_string());
              let map2 = PersistentTreeMap::new()
                  .insert(2, "value".to_string());

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              map1.hash(&mut hasher1);
              map2.hash(&mut hasher2);
              assert_ne!(hasher1.finish(), hasher2.finish());
          }

          /// 異なるサイズのマップは異なるハッシュ値を持つことを確認
          #[rstest]
          fn test_different_size_different_hash() {
              let map1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string());
              let map2 = PersistentTreeMap::new()
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string());

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              map1.hash(&mut hasher1);
              map2.hash(&mut hasher2);
              assert_ne!(hasher1.finish(), hasher2.finish());
          }

          /// 同じマップに対するハッシュは決定的であることを確認
          #[rstest]
          fn test_hash_deterministic() {
              let map = PersistentTreeMap::new()
                  .insert(1, "one".to_string())
                  .insert(2, "two".to_string())
                  .insert(3, "three".to_string());

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              map.hash(&mut hasher1);
              map.hash(&mut hasher2);
              assert_eq!(hasher1.finish(), hasher2.finish());
          }

          // -------------------------------------------------------------------------
          // コレクション使用テスト
          // -------------------------------------------------------------------------

          /// HashMap のキーとして使用可能であることを確認
          #[rstest]
          fn test_hashmap_key() {
              use std::collections::HashMap;

              let mut map: HashMap<PersistentTreeMap<i32, String>, &str> = HashMap::new();
              let key1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string());
              let key2 = PersistentTreeMap::new()
                  .insert(2, "two".to_string());

              map.insert(key1.clone(), "first");
              map.insert(key2.clone(), "second");

              assert_eq!(map.get(&key1), Some(&"first"));
              assert_eq!(map.get(&key2), Some(&"second"));
              let key1_copy = PersistentTreeMap::new()
                  .insert(1, "one".to_string());
              assert_eq!(map.get(&key1_copy), Some(&"first"));
          }

          /// HashSet の要素として使用可能であることを確認
          #[rstest]
          fn test_hashset_element() {
              use std::collections::HashSet;

              let mut set: HashSet<PersistentTreeMap<i32, String>> = HashSet::new();
              set.insert(PersistentTreeMap::new().insert(1, "one".to_string()));
              set.insert(PersistentTreeMap::new().insert(2, "two".to_string()));
              set.insert(PersistentTreeMap::new().insert(1, "one".to_string())); // 重複

              assert_eq!(set.len(), 2);
              assert!(set.contains(&PersistentTreeMap::new().insert(1, "one".to_string())));
              assert!(set.contains(&PersistentTreeMap::new().insert(2, "two".to_string())));
              assert!(!set.contains(&PersistentTreeMap::new().insert(3, "three".to_string())));
          }

          /// PersistentHashSet の要素として使用可能であることを確認
          #[rstest]
          fn test_persistent_hashset_element() {
              use lambars::persistent::PersistentHashSet;

              let treemap1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string());
              let treemap2 = PersistentTreeMap::new()
                  .insert(2, "two".to_string());

              let set = PersistentHashSet::new()
                  .insert(treemap1.clone())
                  .insert(treemap2.clone());

              assert!(set.contains(&treemap1));
              assert!(set.contains(&treemap2));
          }

          /// PersistentHashMap のキーとして使用可能であることを確認
          #[rstest]
          fn test_persistent_hashmap_key() {
              use lambars::persistent::PersistentHashMap;

              let key1 = PersistentTreeMap::new()
                  .insert(1, "one".to_string());
              let key2 = PersistentTreeMap::new()
                  .insert(2, "two".to_string());

              let map = PersistentHashMap::new()
                  .insert(key1.clone(), "first")
                  .insert(key2.clone(), "second");

              assert_eq!(map.get(&key1), Some(&"first"));
              assert_eq!(map.get(&key2), Some(&"second"));
          }

          // -------------------------------------------------------------------------
          // ネストしたマップのハッシュテスト
          // -------------------------------------------------------------------------

          /// ネストしたマップのハッシュが正しく動作することを確認
          #[rstest]
          fn test_nested_treemap_hash() {
              let inner1 = PersistentTreeMap::new()
                  .insert(1, 10)
                  .insert(2, 20);
              let inner2 = PersistentTreeMap::new()
                  .insert(3, 30)
                  .insert(4, 40);

              let nested1: PersistentTreeMap<&str, PersistentTreeMap<i32, i32>> =
                  PersistentTreeMap::new()
                      .insert("first", inner1.clone())
                      .insert("second", inner2.clone());
              let nested2: PersistentTreeMap<&str, PersistentTreeMap<i32, i32>> =
                  PersistentTreeMap::new()
                      .insert("first", inner1)
                      .insert("second", inner2);

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              nested1.hash(&mut hasher1);
              nested2.hash(&mut hasher2);
              assert_eq!(hasher1.finish(), hasher2.finish());
          }

          /// PersistentList を値に持つマップのハッシュが正しく動作することを確認
          #[rstest]
          fn test_treemap_with_persistent_list_values() {
              use lambars::persistent::PersistentList;

              let list1: PersistentList<i32> = (1..=3).collect();
              let list2: PersistentList<i32> = (4..=6).collect();

              let map1: PersistentTreeMap<&str, PersistentList<i32>> =
                  PersistentTreeMap::new()
                      .insert("first", list1.clone())
                      .insert("second", list2.clone());
              let map2: PersistentTreeMap<&str, PersistentList<i32>> =
                  PersistentTreeMap::new()
                      .insert("first", list1)
                      .insert("second", list2);

              let mut hasher1 = DefaultHasher::new();
              let mut hasher2 = DefaultHasher::new();
              map1.hash(&mut hasher1);
              map2.hash(&mut hasher2);
              assert_eq!(hasher1.finish(), hasher2.finish());
          }

          /// ネストしたマップを HashSet で使用できることを確認
          #[rstest]
          fn test_nested_treemap_in_hashset() {
              use std::collections::HashSet;

              let inner1 = PersistentTreeMap::new()
                  .insert(1, 10);
              let inner2 = PersistentTreeMap::new()
                  .insert(2, 20);

              let nested1: PersistentTreeMap<&str, PersistentTreeMap<i32, i32>> =
                  PersistentTreeMap::new()
                      .insert("key", inner1);
              let nested2: PersistentTreeMap<&str, PersistentTreeMap<i32, i32>> =
                  PersistentTreeMap::new()
                      .insert("key", inner2);

              let mut set: HashSet<PersistentTreeMap<&str, PersistentTreeMap<i32, i32>>> =
                  HashSet::new();
              set.insert(nested1.clone());
              set.insert(nested2.clone());

              assert_eq!(set.len(), 2);
          }
      }

  persistent_treemap_laws.rs:
    location: tests/persistent_treemap_laws.rs
    section_to_add: |
      // =============================================================================
      // Hash Laws
      // =============================================================================

      use std::collections::hash_map::DefaultHasher;
      use std::hash::{Hash, Hasher};

      /// ヘルパー関数: マップのハッシュ値を計算
      fn calculate_hash<T: Hash>(value: &T) -> u64 {
          let mut hasher = DefaultHasher::new();
          value.hash(&mut hasher);
          hasher.finish()
      }

      proptest! {
          /// Hash-Eq 一貫性: a == b ならば hash(a) == hash(b)
          #[test]
          fn prop_hash_eq_consistency(
              entries in prop::collection::vec((any::<i32>(), any::<i32>()), 0..50)
          ) {
              let map1: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();
              let map2: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();

              prop_assert_eq!(map1, map2);
              prop_assert_eq!(calculate_hash(&map1), calculate_hash(&map2));
          }

          /// ハッシュの決定性: 同じマップは常に同じハッシュ値を持つ
          #[test]
          fn prop_hash_deterministic(
              entries in prop::collection::vec((any::<i32>(), any::<i32>()), 0..50)
          ) {
              let map: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();

              let hash1 = calculate_hash(&map);
              let hash2 = calculate_hash(&map);

              prop_assert_eq!(hash1, hash2);
          }

          /// 挿入順序に依存しないハッシュ値
          #[test]
          fn prop_hash_insert_order_independent(
              entries in prop::collection::vec((any::<i32>(), any::<i32>()), 2..20)
          ) {
              use rand::seq::SliceRandom;
              use rand::thread_rng;

              let map1: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();

              let mut shuffled = entries.clone();
              shuffled.shuffle(&mut thread_rng());
              let map2: PersistentTreeMap<i32, i32> = shuffled.iter().cloned().collect();

              prop_assert_eq!(map1, map2);
              prop_assert_eq!(calculate_hash(&map1), calculate_hash(&map2));
          }

          /// clone したマップは同じハッシュ値を持つ
          #[test]
          fn prop_hash_clone_consistency(
              entries in prop::collection::vec((any::<i32>(), any::<i32>()), 0..50)
          ) {
              let map: PersistentTreeMap<i32, i32> = entries.iter().cloned().collect();
              let cloned = map.clone();

              prop_assert_eq!(calculate_hash(&map), calculate_hash(&cloned));
          }
      }

# =============================================================================
# 依存関係グラフ
# =============================================================================

dependency_graph:
  requirements:
    FR-001:
      depends_on: []
      description: Hash トレイト実装（基盤）

    FR-002:
      depends_on:
        - FR-001
      description: Hash-Eq 一貫性

    FR-003:
      depends_on:
        - FR-001
      description: HashMap/HashSet での使用

  steps:
    step_1: []
    step_2:
      - step_1
    step_3:
      - step_2
    step_4:
      - step_2
    step_5:
      - step_2
    step_6:
      - step_2
    step_7:
      - step_3
      - step_4
      - step_5
      - step_6

# =============================================================================
# テストカバレッジ要件
# =============================================================================

test_coverage:
  target: 100%

  unit_tests:
    persistent_treemap_tests.rs:
      hash_tests:
        basic:
          - test_empty_treemap_hash
          - test_singleton_treemap_hash
          - test_multi_entry_treemap_hash
        hash_eq_consistency:
          - test_equal_treemaps_same_hash
          - test_different_insert_order_same_hash
          - test_different_treemaps_likely_different_hash
          - test_different_keys_different_hash
          - test_different_size_different_hash
          - test_hash_deterministic
        collection_usage:
          - test_hashmap_key
          - test_hashset_element
          - test_persistent_hashset_element
          - test_persistent_hashmap_key
        nested:
          - test_nested_treemap_hash
          - test_treemap_with_persistent_list_values
          - test_nested_treemap_in_hashset

  law_tests:
    persistent_treemap_laws.rs:
      hash_laws:
        - prop_hash_eq_consistency
        - prop_hash_deterministic
        - prop_hash_insert_order_independent
        - prop_hash_clone_consistency

# =============================================================================
# 成功基準
# =============================================================================

success_criteria:

  functional:
    - 全ての要件（FR-001, FR-002, FR-003）が実装されていること
    - Hash-Eq 一貫性が満たされていること（proptest で検証）
    - 挿入順序に依存しないハッシュ値であること
    - HashMap/HashSet のキー・要素として使用可能であること
    - PersistentHashMap/PersistentHashSet との統合が動作すること
    - ネストしたマップのハッシュが正しく動作すること
    - PersistentList を値に持つマップのハッシュが正しく動作すること

  code_quality:
    - テストカバレッジ 100%
    - "#![forbid(unsafe_code)] を維持"
    - clippy 警告なし
    - ドキュメントコメント完備

  non_functional:
    - ハッシュ計算の計算量が O(n) であること
    - 後方互換性が維持されていること（既存コードに影響なし）

# =============================================================================
# 実装スケジュール目安
# =============================================================================

estimated_timeline:
  unit: hours

  steps:
    step_1_basic_tests: 0.5
    step_2_implementation: 0.5
    step_3_consistency_tests: 0.5
    step_4_collection_tests: 0.5
    step_5_nested_tests: 0.5
    step_6_property_tests: 0.5
    step_7_refactor: 0.5

  total_estimated_hours: 3.5

  notes: |
    - TDD サイクル（テスト作成 -> 実装 -> リファクタリング）の時間を含む
    - 実装自体はシンプルなため、短時間で完了可能
    - PersistentTreeMap は順序付きマップであるため、iter() がキー順でエントリを返すことを活用
    - テストの網羅性を重視（挿入順序非依存性のテストが重要）
