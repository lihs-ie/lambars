# Phase 13: Guard Expression Implementation Plan
# for_! および for_async! マクロへのガード式サポート追加の実装計画
# TDD アプローチに基づく段階的実装

version: "1.0.0"
created_at: "2026-01-03"
phase_id: phase_13
requirements_document: docs/phase_13_requirements/phase_13_guard_expression.yaml

# =============================================================================
# 実装概要
# =============================================================================

implementation_overview:
  description: |
    for_! および for_async! マクロにガード式（if condition;）を追加する。
    既存のマクロルールの構造を維持しつつ、適切な位置に if パターンを追加する。
    TDD アプローチにより、テストを先に書いてから実装を進める。

  approach: |
    1. マクロの内部ルール（@collect, @inner）に if パターンを追加
    2. 既存のルールとの順序を適切に設定（優先度の高いルールを先に配置）
    3. for_! は vec![] を返すことでスキップを実現
    4. for_async! は何もしない（push しない）ことでスキップを実現

  key_considerations:
    - マクロルールの順序が重要（特定パターンを先にマッチさせる）
    - if キーワードは Rust の予約語だが、マクロパターンでは使用可能
    - セミコロン必須により、他のパターンとの競合を回避
    - 既存のテストが引き続き通過することを確認

# =============================================================================
# 実装ステップ
# =============================================================================

implementation_steps:

  # ---------------------------------------------------------------------------
  # Step 1: テストファイルの作成（Red Phase）
  # ---------------------------------------------------------------------------
  - step: 1
    name: 統合テストファイルの作成
    description: |
      ガード式の動作を検証する統合テストファイルを作成する。
      テストは最初は失敗する（Red Phase）。

    tdd_phase: red

    artifacts:
      - path: tests/for_guard_tests.rs
        action: create

    test_cases:
      - name: test_for_guard_basic_filter
        description: 基本的なガード式による偶数フィルタ
        code: |
          #[test]
          fn test_for_guard_basic_filter() {
              let result = for_! {
                  x <= vec![1, 2, 3, 4, 5];
                  if x % 2 == 0;
                  yield x
              };
              assert_eq!(result, vec![2, 4]);
          }

      - name: test_for_guard_all_pass
        description: 全要素がガードを通過する場合
        code: |
          #[test]
          fn test_for_guard_all_pass() {
              let result = for_! {
                  x <= vec![2, 4, 6, 8];
                  if x % 2 == 0;
                  yield x
              };
              assert_eq!(result, vec![2, 4, 6, 8]);
          }

      - name: test_for_guard_all_fail
        description: 全要素がガードで除外される場合
        code: |
          #[test]
          fn test_for_guard_all_fail() {
              let result = for_! {
                  x <= vec![1, 3, 5, 7];
                  if x % 2 == 0;
                  yield x
              };
              assert_eq!(result, Vec::<i32>::new());
          }

      - name: test_for_guard_empty_collection
        description: 空コレクションの場合
        code: |
          #[test]
          fn test_for_guard_empty_collection() {
              let result = for_! {
                  x <= Vec::<i32>::new();
                  if x > 0;
                  yield x
              };
              assert!(result.is_empty());
          }

      - name: test_for_guard_nested_iteration
        description: ネストしたイテレーションでのガード
        code: |
          #[test]
          fn test_for_guard_nested_iteration() {
              let result = for_! {
                  x <= vec![1, 2, 3];
                  y <= vec![10, 20, 30];
                  if x + y > 20;
                  yield (x, y)
              };
              // (1,20), (1,30), (2,20), (2,30), (3,10), (3,20), (3,30) = 7個
              assert_eq!(result.len(), 7);
              assert!(result.contains(&(1, 20)));
              assert!(result.contains(&(3, 30)));
          }

      - name: test_for_guard_between_binds
        description: バインドの間にガードを配置
        code: |
          #[test]
          fn test_for_guard_between_binds() {
              let result = for_! {
                  x <= vec![1, 2, 3, 4];
                  if x % 2 == 0;
                  y <= vec![10, 20];
                  yield (x, y)
              };
              // x=2,4 のみが残り、各々 y=10,20 と組み合わせ
              assert_eq!(result, vec![(2, 10), (2, 20), (4, 10), (4, 20)]);
          }

      - name: test_for_guard_multiple_consecutive
        description: 連続した複数のガード式
        code: |
          #[test]
          fn test_for_guard_multiple_consecutive() {
              let result = for_! {
                  x <= 1..=100i32;
                  if x % 2 == 0;
                  if x % 3 == 0;
                  if x < 50;
                  yield x
              };
              // 6, 12, 18, 24, 30, 36, 42, 48
              assert_eq!(result, vec![6, 12, 18, 24, 30, 36, 42, 48]);
          }

      - name: test_for_guard_after_let
        description: let 束縛の後にガード
        code: |
          #[test]
          fn test_for_guard_after_let() {
              let result = for_! {
                  x <= vec![1, 2, 3, 4, 5];
                  let squared = x * x;
                  if squared > 10;
                  yield squared
              };
              assert_eq!(result, vec![16, 25]);
          }

      - name: test_for_guard_before_let
        description: ガードの後に let 束縛
        code: |
          #[test]
          fn test_for_guard_before_let() {
              let result = for_! {
                  x <= vec![1, 2, 3, 4, 5];
                  if x > 2;
                  let doubled = x * 2;
                  yield doubled
              };
              assert_eq!(result, vec![6, 8, 10]);
          }

      - name: test_for_guard_with_tuple_pattern
        description: タプルパターンでのガード
        code: |
          #[test]
          fn test_for_guard_with_tuple_pattern() {
              let pairs = vec![(1, 2), (3, 4), (5, 6), (10, 20)];
              let result = for_! {
                  (a, b) <= pairs;
                  if b - a > 1;
                  yield (a, b)
              };
              assert_eq!(result, vec![(10, 20)]);
          }

      - name: test_for_guard_with_external_function
        description: 外部関数をガード条件として使用
        code: |
          fn is_prime(n: i32) -> bool {
              if n < 2 { return false; }
              (2..=((n as f64).sqrt() as i32)).all(|i| n % i != 0)
          }

          #[test]
          fn test_for_guard_with_external_function() {
              let result = for_! {
                  x <= 1..=20i32;
                  if is_prime(x);
                  yield x
              };
              assert_eq!(result, vec![2, 3, 5, 7, 11, 13, 17, 19]);
          }

      - name: test_for_guard_interleaved_complex
        description: バインド、ガード、let の複雑な組み合わせ
        code: |
          #[test]
          fn test_for_guard_interleaved_complex() {
              let result = for_! {
                  x <= vec![1, 2, 3];
                  if x > 1;
                  y <= vec![10, 20, 30];
                  let sum = x + y;
                  if sum > 25;
                  let product = x * y;
                  yield (sum, product)
              };
              // x=2: y=20 -> (22, 40) NG, y=30 -> (32, 60) OK
              // x=3: y=10 -> (13, 30) NG, y=20 -> (23, 60) NG, y=30 -> (33, 90) OK
              assert_eq!(result, vec![(32, 60), (33, 90)]);
          }

    async_test_cases:
      - name: test_for_async_guard_basic_filter
        description: for_async! での基本的なガード
        code: |
          #[tokio::test]
          async fn test_for_async_guard_basic_filter() {
              let result = for_async! {
                  x <= vec![1, 2, 3, 4, 5];
                  if x % 2 == 0;
                  yield x
              };
              assert_eq!(result.run_async().await, vec![2, 4]);
          }

      - name: test_for_async_guard_with_async_bind
        description: AsyncIO バインドとガードの組み合わせ
        code: |
          #[tokio::test]
          async fn test_for_async_guard_with_async_bind() {
              use crate::effect::AsyncIO;

              let result = for_async! {
                  x <= vec![1, 2, 3, 4, 5];
                  data <~ AsyncIO::pure(x * 10);
                  if data > 20;
                  yield data
              };
              assert_eq!(result.run_async().await, vec![30, 40, 50]);
          }

      - name: test_for_async_guard_multiple
        description: for_async! での複数ガード
        code: |
          #[tokio::test]
          async fn test_for_async_guard_multiple() {
              let result = for_async! {
                  x <= 1..=20i32;
                  if x % 2 == 0;
                  if x > 10;
                  yield x
              };
              assert_eq!(result.run_async().await, vec![12, 14, 16, 18, 20]);
          }

      - name: test_for_async_guard_with_let
        description: for_async! でのガードと let の組み合わせ
        code: |
          #[tokio::test]
          async fn test_for_async_guard_with_let() {
              let result = for_async! {
                  x <= vec![1, 2, 3, 4, 5];
                  let squared = x * x;
                  if squared > 10;
                  yield squared
              };
              assert_eq!(result.run_async().await, vec![16, 25]);
          }

  # ---------------------------------------------------------------------------
  # Step 2: for_! マクロへのガード式ルール追加（Green Phase）
  # ---------------------------------------------------------------------------
  - step: 2
    name: for_! マクロへのガード式ルール追加
    description: |
      for_! マクロの @collect 内部ルールにガード式パターンを追加する。
      ルールの配置順序に注意し、既存のルールより前に配置する。

    tdd_phase: green

    artifacts:
      - path: src/compose/for_macro.rs
        action: modify

    implementation_details:
      rule_placement: |
        @collect ルールの中で、以下の順序でルールを配置する:
        1. 既存の単一イテレーション最適化ルール（yield 直前）
        2. 【新規】ガード式ルール（if condition;）
        3. 既存のバインドルール（pattern <= collection;）
        4. 既存の let 束縛ルール

      new_rules: |
        // =========================================================================
        // @collect ガード式ルール
        // =========================================================================

        // @collect ガード式（後続の処理あり）
        (@collect if $condition:expr ; $($rest:tt)+) => {{
            if $condition {
                $crate::for_!(@collect $($rest)+)
            } else {
                vec![]
            }
        }};

      insertion_point: |
        行320-319の間（@collect let binding with identifier の直前）に挿入する。
        これにより、ガード式が let 束縛より先にマッチされる。

    code_changes:
      - description: "@collect ガード式ルールの追加"
        location: "行319-320の間"
        before: |
          // @collect let binding with identifier
          (@collect let $pattern:ident = $expr:expr ; $($rest:tt)+) => {{
        after: |
          // @collect ガード式（後続の処理あり）
          (@collect if $condition:expr ; $($rest:tt)+) => {{
              if $condition {
                  $crate::for_!(@collect $($rest)+)
              } else {
                  vec![]
              }
          }};

          // @collect let binding with identifier
          (@collect let $pattern:ident = $expr:expr ; $($rest:tt)+) => {{

    verification:
      - 既存の全テストが通過すること
      - 新規のガード式テストが通過すること
      - clippy 警告がないこと

  # ---------------------------------------------------------------------------
  # Step 3: for_async! マクロへのガード式ルール追加（Green Phase）
  # ---------------------------------------------------------------------------
  - step: 3
    name: for_async! マクロへのガード式ルール追加
    description: |
      for_async! マクロの @inner 内部ルールにガード式パターンを追加する。

    tdd_phase: green

    artifacts:
      - path: src/compose/for_async_macro.rs
        action: modify

    implementation_details:
      rule_placement: |
        @inner ルールの中で、以下の順序でルールを配置する:
        1. Terminal case: yield expression
        2. 【新規】ガード式ルール（if condition;）
        3. AsyncIO bind rules
        4. Collection bind rules
        5. Pure let binding rules

      new_rules: |
        // @inner ガード式（後続の処理あり）
        (@inner $results:ident; if $condition:expr ; $($rest:tt)+) => {{
            if $condition {
                $crate::for_async!(@inner $results; $($rest)+);
            }
        }};

      insertion_point: |
        行312-314の間（Terminal case の直後、AsyncIO bind の直前）に挿入する。

    code_changes:
      - description: "@inner ガード式ルールの追加"
        location: "行312-314の間"
        before: |
          // Terminal case: yield expression
          (@inner $results:ident; yield $result:expr) => {{
              $results.push($result);
          }};

          // AsyncIO bind with identifier pattern
        after: |
          // Terminal case: yield expression
          (@inner $results:ident; yield $result:expr) => {{
              $results.push($result);
          }};

          // @inner ガード式（後続の処理あり）
          (@inner $results:ident; if $condition:expr ; $($rest:tt)+) => {{
              if $condition {
                  $crate::for_async!(@inner $results; $($rest)+);
              }
          }};

          // AsyncIO bind with identifier pattern

    verification:
      - 既存の全テストが通過すること
      - 新規の async ガード式テストが通過すること
      - clippy 警告がないこと

  # ---------------------------------------------------------------------------
  # Step 4: インラインテストの追加
  # ---------------------------------------------------------------------------
  - step: 4
    name: インラインテストの追加
    description: |
      各マクロファイル内にインラインテストを追加する。
      これにより、モジュール単位でのテスト実行が可能になる。

    tdd_phase: green

    artifacts:
      - path: src/compose/for_macro.rs
        action: modify
      - path: src/compose/for_async_macro.rs
        action: modify

    for_macro_inline_tests:
      - name: test_guard_basic_filter
        code: |
          #[test]
          fn test_guard_basic_filter() {
              let result = for_! {
                  x <= vec![1, 2, 3, 4, 5];
                  if x % 2 == 0;
                  yield x
              };
              assert_eq!(result, vec![2, 4]);
          }

      - name: test_guard_all_pass
        code: |
          #[test]
          fn test_guard_all_pass() {
              let result = for_! {
                  x <= vec![2, 4, 6];
                  if x % 2 == 0;
                  yield x
              };
              assert_eq!(result, vec![2, 4, 6]);
          }

      - name: test_guard_all_fail
        code: |
          #[test]
          fn test_guard_all_fail() {
              let result = for_! {
                  x <= vec![1, 3, 5];
                  if x % 2 == 0;
                  yield x
              };
              assert!(result.is_empty());
          }

      - name: test_guard_empty_collection
        code: |
          #[test]
          fn test_guard_empty_collection() {
              let result = for_! {
                  x <= Vec::<i32>::new();
                  if x > 0;
                  yield x
              };
              assert!(result.is_empty());
          }

      - name: test_guard_after_let
        code: |
          #[test]
          fn test_guard_after_let() {
              let result = for_! {
                  x <= vec![1, 2, 3, 4, 5];
                  let squared = x * x;
                  if squared > 10;
                  yield squared
              };
              assert_eq!(result, vec![16, 25]);
          }

      - name: test_guard_nested
        code: |
          #[test]
          fn test_guard_nested() {
              let result = for_! {
                  x <= vec![1, 2];
                  y <= vec![10, 20];
                  if x + y > 15;
                  yield (x, y)
              };
              assert_eq!(result, vec![(1, 20), (2, 20)]);
          }

      - name: test_guard_multiple
        code: |
          #[test]
          fn test_guard_multiple() {
              let result = for_! {
                  x <= 1..=20i32;
                  if x % 2 == 0;
                  if x > 10;
                  yield x
              };
              assert_eq!(result, vec![12, 14, 16, 18, 20]);
          }

      - name: test_guard_between_binds
        code: |
          #[test]
          fn test_guard_between_binds() {
              let result = for_! {
                  x <= vec![1, 2, 3];
                  if x % 2 == 1;
                  y <= vec![10, 20];
                  yield (x, y)
              };
              assert_eq!(result, vec![(1, 10), (1, 20), (3, 10), (3, 20)]);
          }

    for_async_macro_inline_tests:
      - name: test_async_guard_basic
        code: |
          #[tokio::test]
          async fn test_async_guard_basic() {
              let result = for_async! {
                  x <= vec![1, 2, 3, 4, 5];
                  if x % 2 == 0;
                  yield x
              };
              assert_eq!(result.run_async().await, vec![2, 4]);
          }

      - name: test_async_guard_multiple
        code: |
          #[tokio::test]
          async fn test_async_guard_multiple() {
              let result = for_async! {
                  x <= 1..=20i32;
                  if x % 2 == 0;
                  if x > 10;
                  yield x
              };
              assert_eq!(result.run_async().await, vec![12, 14, 16, 18, 20]);
          }

  # ---------------------------------------------------------------------------
  # Step 5: ドキュメント更新
  # ---------------------------------------------------------------------------
  - step: 5
    name: ドキュメント更新
    description: |
      各マクロのモジュールドキュメントにガード式の説明を追加する。

    tdd_phase: refactor

    artifacts:
      - path: src/compose/for_macro.rs
        action: modify
      - path: src/compose/for_async_macro.rs
        action: modify

    documentation_additions:
      for_macro:
        syntax_section: |
          ## Syntax の更新（行16-20付近）

          ```text
          for_! {
              pattern <= collection;    // Bind: iterate over collection
              if condition;             // Guard: filter by condition (NEW)
              let pattern = expression; // Pure let binding
              yield expression          // Final expression (wrapped in Vec)
          }
          ```

        guard_example: |
          ## Guard Expression の例を追加

          ```rust
          use lambars::for_;

          // Basic guard
          let result = for_! {
              x <= vec![1, 2, 3, 4, 5];
              if x % 2 == 0;
              yield x
          };
          assert_eq!(result, vec![2, 4]);

          // Multiple guards
          let result = for_! {
              x <= 1..=100i32;
              if x % 2 == 0;
              if x % 3 == 0;
              if x < 50;
              yield x
          };
          assert_eq!(result, vec![6, 12, 18, 24, 30, 36, 42, 48]);

          // Guard with let binding
          let result = for_! {
              x <= vec![1, 2, 3, 4, 5];
              let squared = x * x;
              if squared > 10;
              yield squared
          };
          assert_eq!(result, vec![16, 25]);
          ```

        supported_patterns_update: |
          ## Supported Patterns セクションの更新

          - **Guard expression**: `if condition;` (skips if condition is false)

      for_async_macro:
        syntax_section: |
          ## Syntax の更新

          ```text
          for_async! {
              pattern <= collection;           // Bind: iterate over collection
              pattern <~ async_io_expression;  // Async Bind: await AsyncIO result
              if condition;                    // Guard: filter by condition (NEW)
              let pattern = expression;        // Pure let binding
              yield expression                 // Final expression (collected in Vec)
          }
          ```

  # ---------------------------------------------------------------------------
  # Step 6: 最終検証
  # ---------------------------------------------------------------------------
  - step: 6
    name: 最終検証
    description: |
      全てのテストを実行し、実装が正しいことを確認する。
      パフォーマンスの影響がないことも確認する。

    tdd_phase: verification

    verification_commands:
      - command: "cargo test --all-features"
        description: 全テストの実行

      - command: "cargo clippy --all-features -- -D warnings"
        description: clippy チェック

      - command: "cargo doc --all-features --no-deps"
        description: ドキュメント生成確認

    checklist:
      - 全ての既存テストが通過すること
      - 全ての新規テストが通過すること
      - clippy 警告がないこと
      - ドキュメントが正しく生成されること
      - #![forbid(unsafe_code)] が維持されていること

# =============================================================================
# テストカバレッジ戦略
# =============================================================================

test_coverage_strategy:
  description: |
    ガード式の全ての使用パターンをカバーするテストを作成する。
    既存のテストとの重複を避けつつ、新機能の網羅的な検証を行う。

  categories:
    - name: 基本ガード式
      tests:
        - 単一ガード、条件 true
        - 単一ガード、条件 false
        - 全要素がガードを通過
        - 全要素がガードで除外
        - 空コレクション

    - name: ネストイテレーション
      tests:
        - 2重ネストの最後にガード
        - 2重ネストの間にガード
        - 3重ネストでの複数ガード

    - name: 複数ガード
      tests:
        - 連続した2つのガード
        - 連続した3つ以上のガード
        - AND 条件相当の動作確認

    - name: let 束縛との組み合わせ
      tests:
        - let の後にガード
        - ガードの後に let
        - let で計算した値をガードで使用

    - name: パターンとの組み合わせ
      tests:
        - タプルパターン + ガード
        - ワイルドカード + ガード

    - name: 外部関数
      tests:
        - 外部関数をガード条件として使用
        - クロージャをガード条件として使用

    - name: for_async! 固有
      tests:
        - 基本ガード（同期）
        - AsyncIO バインド + ガード
        - 複数ガード + AsyncIO

# =============================================================================
# リスクと対策
# =============================================================================

risks_and_mitigations:

  - risk: マクロルールの順序による予期しないマッチ
    severity: medium
    mitigation: |
      - ガード式ルールを適切な位置（let 束縛の前）に配置
      - 既存のテストケースが全て通過することを確認
      - 複雑なパターンのテストを追加

  - risk: if キーワードとの競合
    severity: low
    mitigation: |
      - Rust のマクロでは if はキーワードとしてマッチ可能
      - セミコロン必須により、通常の if 文との区別が明確
      - 実際にコンパイルして動作確認

  - risk: パフォーマンスへの影響
    severity: low
    mitigation: |
      - ガード式は単純な if 文に展開されるため、オーバーヘッドは最小
      - 既存のベンチマークに影響がないことを確認
      - 必要に応じてマイクロベンチマークを追加

  - risk: 既存コードとの後方互換性
    severity: medium
    mitigation: |
      - 新しいルールは追加のみ、既存ルールは変更しない
      - 全ての既存テストが通過することを確認
      - samples/ 配下のコードが引き続きビルドできることを確認

# =============================================================================
# 成果物サマリー
# =============================================================================

artifacts_summary:
  modified_files:
    - path: src/compose/for_macro.rs
      changes:
        - "@collect ガード式ルールの追加"
        - "モジュールドキュメントの更新"
        - "インラインテストの追加"

    - path: src/compose/for_async_macro.rs
      changes:
        - "@inner ガード式ルールの追加"
        - "モジュールドキュメントの更新"
        - "インラインテストの追加"

  new_files:
    - path: tests/for_guard_tests.rs
      description: ガード式の統合テスト

# =============================================================================
# 実装時間見積もり
# =============================================================================

time_estimates:
  step_1_tests: "30分"
  step_2_for_macro: "20分"
  step_3_for_async_macro: "20分"
  step_4_inline_tests: "20分"
  step_5_documentation: "20分"
  step_6_verification: "15分"
  total: "約2時間"

# =============================================================================
# 参照
# =============================================================================

references:
  - name: "要件定義"
    path: "docs/phase_13_requirements/phase_13_guard_expression.yaml"

  - name: "現在の for_! マクロ実装"
    path: "src/compose/for_macro.rs"

  - name: "現在の for_async! マクロ実装"
    path: "src/compose/for_async_macro.rs"

  - name: "Rust macro_rules! ドキュメント"
    url: "https://doc.rust-lang.org/reference/macros-by-example.html"

  - name: "Scala for-comprehension ガード"
    url: "https://docs.scala-lang.org/tour/for-comprehensions.html"
