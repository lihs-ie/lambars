# 概要

Rust で関数型プログラミングを行うために標準で提供していない関数型プログラミングの API を作成する

# 技術要件

- Rust: 1.92.0
- edition: 2024
- testing: rstest

# 実装手順

1. サブエージェント: functional-programming-specialist を起動し Rust に「真の関数型プログラミング」を実現する上で足りていないもの を読み現状の課題を把握する
   1-2. references/rust のコードを調査し、課題を解決するための方法をステップバイステップで考える
   1-3. functional-programming-specialist は課題一つ一つに対し要件定義を yaml ファイルで作成する
   1-4. rust-implementation-reviewer を起動し要件定義に対して実装計画を yaml ファイルで作成する
   1-5 functional-programming-specialist は 1-4 の実装計画が要件定義と異なる点がなくなるまでレビュー指摘を行う
   1-6. レビュー指摘がなくなるまで 1-4 と 1-5 を繰り返す
2. サブエージェント: rust-implementation-specialist を起動し実装計画に則って TDD で実装を行う
3. rust-implementation-reviewer を起動して実装のレビューを行う
   1. 略語を使用していないこと
   2. 差分の対象となるテストのみを実行し失敗していないこと
   3. 差分の対象となるテストのカバレッジ 100%であること
   4. レビュー指摘がなくなるまで修正とレビューを繰り返す
4. functional-programming-specialist 　を起動し要件定義の観点から実装をレビューする
5. @docs/roadmap.yaml を更新する
6. 実装上困難だと判断した場合は @docs/phase_1_future_work.yaml と同じフォーマットで phase ごとに将来の拡張案としてファイルを書き出すこと

# Rust で関数型プログラミングを行うための考察（**実装に迷った時にっ読み直す**）

# Rust に「真の関数型プログラミング」を実現する上で足りていないもの

> ここでは一般に“関数型言語らしさ”とされる **純粋性・参照透過性・不変性・高い抽象化能力（型による合成）・遅延評価・副作用の明示/制御** などを総称して扱い、Rust が“言語として標準装備していない／強くは支援していない”点を洗い出します。

---

## 0. 先に結論（要点）

Rust は「関数型っぽく書ける」ための材料（代数的データ型、パターンマッチ、イテレータ、クロージャ、`Option`/`Result`、式中心の構文など）を多く持ちます。一方で「純粋関数型言語（Haskell 等）が持つ“言語機構としての強制力”」は持たず、次のような要素が不足しています。

- **純粋性・副作用の型レベル追跡（Effect System / Purity）**
- **高階型（HKT）と、それに支えられた抽象（Functor/Applicative/Monad 等）の“素直な汎用化”**
- **より強力で一貫した型推論（Hindley–Milner 的推論の範囲・一貫性）**
- **遅延評価が言語の既定（laziness by default）であること**
- **代数的効果（algebraic effects）や継続/ハンドラ等の“効果の合成”の言語サポート**
- **末尾呼び出し最適化（TCO）の保証と、再帰中心スタイルを支えるスタック安全性**
- **不変・永続データ構造（persistent data structures）の標準搭載**
- **関数合成・部分適用・パイプライン等の“関数型記法”の標準構文**
- **線形型/所有権と、純粋 FP の抽象（特に共有・永続構造・高階抽象）の摩擦を埋める機構**

---

## 1. 「真の関数型」に必要とされがちな要件

ここでは議論の土台として、純粋関数型言語が“言語機構として”提供しがちな能力を整理します。

### 1.1 参照透過性と純粋性

- 同じ入力なら常に同じ出力（外部状態・I/O・時刻等に依存しない）
- 副作用は明示的（型や構文で隔離）

### 1.2 不変性と永続データ構造

- データは更新ではなく“新しい値”を作る
- 構造的共有により効率よく不変更新できる

### 1.3 強い合成性（抽象）

- 型クラスや HKT などを基盤に、抽象を“汎用に”定義できる
- Functor/Applicative/Monad/Traversable 等で合成のパターンが統一

### 1.4 遅延評価・ストリーム・無限構造

- 言語既定の遅延により、無限列や合成が自然に書ける

### 1.5 効果の合成（Effect composition）

- 例: 例外、状態、I/O、非決定性、非同期、ログ等
- それらを安全に組み合わせ、局所化し、取り回す

### 1.6 再帰と高階関数中心の記述を支える最適化

- TCO 保証・最適化（deforestation/fusion 等）

Rust はこれらのうち「一部」を強く支援しつつ、別の要素は設計方針上“敢えて”持っていません。

---

## 2. Rust がすでに持っている関数型寄りの強み（前提の整理）

不足点を挙げる前に、Rust がすでに持つ“関数型的に書ける理由”を確認します。

- **代数的データ型（ADT）**: `enum` + `struct`
- **パターンマッチ**: `match` / `if let` / `let-else`
- **イテレータと高階関数**: `map`/`filter`/`fold`/`flat_map` 等
- **クロージャ**: キャプチャの仕組み（`Fn`/`FnMut`/`FnOnce`）
- **`Option`/`Result`** と合成（`?`, `and_then`, `map`）
- **不変がデフォルト**: `let` は基本的に immutable（`mut` が必要）
- **式中心に書ける構文**: `match` も式

つまり Rust は「FP の道具箱」は多い。ただし「FP を強制する型体系・評価戦略・効果システム」は別問題です。

---

## 3. 言語機能として足りていないもの（コア機構）

ここからが本題です。

### 3.1 純粋性（Purity）を強制・追跡する仕組み（Effect System）

**何が足りないか**

- 関数が副作用を持つかどうかを、言語が強制的に区別できない
- 「この関数は I/O する」「この関数は状態を書く」などが型で表現されない

**Rust の現状**

- 副作用は“できてしまう”
- `unsafe` のように境界が明確なものもあるが、I/O やグローバル状態は型で追跡されない

**真の FP 的に欲しいもの**

- 例としては次のような発想（言語機構）
  - `pure fn` と `impure fn` の区別
  - エフェクト（I/O, State, Exception 等）を型パラメータとして持つ
  - “効果の多相性（polymorphic effects）”

**なぜ重要か**

- “参照透過性を前提にした推論・最適化・テスト容易性”が得にくい
- API 設計で「副作用がある/ない」を型で示せない

---

### 3.2 高階型（Higher-Kinded Types, HKT）の欠如

**何が足りないか**

- `F<_>` のような「型コンストラクタそのもの」を抽象化できない

**影響**

- Functor/Applicative/Monad/Traversable などの抽象を、
  - “一度定義して、コンテナ一般に適用する”
    という形で素直に表現しにくい
- 結果として、
  - `Option` には `map` がある
  - `Result` にも `map` がある
  - `Iterator` にも `map` がある
    という“型ごとに似た概念が分散しがち”

**Rust での典型的な回避策**

- associated types / generic associated types（GAT） / 新しい型（newtype） / マクロ
- ただし「HKT がある世界の簡潔さ・統一感」には届きにくい

---

### 3.3 より強力で一貫した型推論（特に高階抽象との相性）

**何が足りないか**

- HM 型推論のように“ほぼ注釈なしで抽象的な関数が書ける”体験
- 高階抽象（特に HKT 相当のこと）をするほど型注釈が増えやすい

**Rust の現状**

- 局所的推論は強いが、抽象が増えるほど型が前面に出やすい
- ライフタイム、トレイト境界、associated type が絡むと特に顕著

**真の FP 的に欲しいもの**

- より自動的・一貫した推論（注釈が最小で済む）
- ただしこれはコンパイル時間やエラーメッセージ品質とトレードオフ

---

### 3.4 遅延評価が既定ではない（Strict by default）

**何が足りないか**

- 評価戦略としての“既定の遅延”

**影響**

- 無限リストのような表現を言語機構で自然に扱いにくい
- 合成の仕方が「遅延が前提の設計」になりにくい

**Rust の現状**

- 基本は正格評価
- 遅延はイテレータやクロージャで実現できるが、
  - “言語の既定”ではなく“明示的に作るもの”

**真の FP 的に欲しいもの**

- 遅延構造（thunk）や遅延パターンが言語の中心にある
- その上で strictness を必要に応じて選べる

---

### 3.5 代数的効果（Algebraic Effects）とハンドラ

**何が足りないか**

- 例外・状態・非同期・ログ等を「合成可能な“効果”」として、
  - プログラム全体で整合的に扱う言語機構

**Rust の現状**

- `Result` による例外相当、`async/await` による非同期、
  共有状態は `Mutex`/`RwLock` などで表現可能
- ただし、
  - “効果の合成”は主にライブラリ設計に委ねられ、統一的になりにくい

**真の FP 的に欲しいもの**

- `do` 記法や effect handler など、
  “効果をプログラムとして合成・切り替え・局所化する”機構

---

### 3.6 末尾呼び出し最適化（TCO）の保証がない

**何が足りないか**

- 再帰中心の記述（fold/再帰下降/木処理など）を安心して書くための保証

**Rust の現状**

- 末尾再帰最適化は保証されない
- 深い再帰はスタックオーバーフローになりうる

**真の FP 的に欲しいもの**

- TCO の言語仕様としての保証、または同等のスタック安全機構

---

### 3.7 「関数型記法」や合成を支える標準構文

**何が足りないか（代表例）**

- パイプライン演算子（`|>` 的な合成）
- 部分適用を自然に書く構文（プレースホルダ `_` など）
- 関数合成演算子（`(f . g)` 的なもの）
- point-free style を素直に書ける構文

**Rust の現状**

- メソッドチェーン（`x.iter().map(...).filter(...).collect()`）は強力
- ただし「関数そのものの合成」や「部分適用」は書き味が重くなりがち

**真の FP 的に欲しいもの**

- “合成を第一級にする記法”が標準にあると、抽象が扱いやすい

---

### 3.8 「不変の世界」を標準で支える仕組みが弱い（永続データ構造）

**何が足りないか**

- `std` における永続データ構造（persistent map/set/vector 等）
- 構造的共有により、
  - 不変更新を自然で高速にする基盤

**Rust の現状**

- `Vec`, `HashMap` などは基本的に可変更新向き
- 不変でも使えるが、コピーや再割り当てのコストが前に出やすい

**真の FP 的に欲しいもの**

- “不変更新が当たり前”のデータ構造と、その最適化
- さらに言語/コンパイラがそれを前提に最適化できると強い

---

### 3.9 共有と所有権（Ownership）の摩擦を小さくする“純粋 FP 向け”の型/機構

**何が足りないか（方向性）**

- 純粋 FP が多用する「構造的共有」や「永続構造」のために、
  - GC や参照カウント、リージョン推論などが自然に統合されていること
- Rust は所有権で安全を得るが、
  - 抽象を積むほど `Arc`/`Rc`/`clone`/ライフタイムが目立ちやすい

**Rust の現状**

- `Rc`/`Arc` と借用で共有はできる
- ただし「純粋関数型の抽象を前提に“最小摩擦”で共有する」体験とは別

**真の FP 的に欲しいもの**

- “効果と資源管理”の整合的な統合
- 例: 線形型/アフィン型を純粋関数型の抽象と一体化させる設計

---

### 3.10 “型によるプログラミング”をより手軽にする仕組み（メタプログラミングの型統合）

**何が足りないか**

- 型レベル計算・型クラス導出・自動インスタンス生成がより言語的に統合されていること

**Rust の現状**

- マクロや derive で拡張可能
- ただし、
  - “型推論と型レベル機構が一体”になった関数型言語の体験とは違い、
  - マクロは別レイヤになりやすい

---

## 4. ライブラリ/標準ライブラリ/エコシステム面で足りていないもの

言語が持たないものをライブラリが補うのは Rust の強みでもありますが、
“真の FP”を前提にしたとき、標準としては不足しがちな領域があります。

### 4.1 永続データ構造・不変コレクションの“標準”

- 不変ベクタ/マップ/セット
- 効率的な構造的共有
- 差分（diff）やスナップショットの扱いやすさ

### 4.2 Optics（Lens/Prism）や構造更新の体系

- 深い入れ子の不変更新を、型安全かつ簡潔に書く道具

### 4.3 効果の合成を統一するフレームワーク

- Result/Option/Iterator/async の“合成の型”が分散している問題を、
  統一的な抽象で扱う土台

### 4.4 Fusion/Deforestation（中間構造の除去）に寄った最適化文化

- Rust は LLVM 最適化が強い一方、
  - 関数合成を前提とした“中間データ構造除去”は言語設計としての前提ではない

### 4.5 プロパティベーステストや等式推論の標準化

- 関数型では「等式としての性質」をテスト・検証しやすい
- Rust にも手段はあるが、標準文化としては分散しがち

---

## 5. 「なぜ Rust はそれを持たないのか」（設計思想とのトレードオフ）

不足点の多くは、Rust の目的（安全・高速・制御可能・ゼロコスト抽象）と衝突しやすいからです。

### 5.1 Purity/Effect System は設計・学習コストが大きい

- 効果多相や効果推論は言語を複雑にしやすい
- エラーメッセージも難しくなりがち

### 5.2 HKT・強い型推論はコンパイルや複雑性と相性が悪い場合がある

- Rust はすでに強い型システム + ライフタイムを持つ
- さらに HKT や推論を積むと、
  - 実装も利用者体験も難しくなりうる

### 5.3 遅延評価は予測可能な性能と相性が悪い

- Rust は“いつ何が評価されるか”を明確にしたい
- 遅延はメモリ保持や評価タイミングがブラックボックスになりやすい

### 5.4 GC を前提にしないことが Rust の大きな特徴

- 永続構造や共有は GC と相性がよい設計が多い
- Rust は所有権で解決するため、純粋 FP の書き味とはズレが出る

---

## 6. 「真の FP」に近づけるために“言語として”欲しい拡張（提案リスト）

ここでは“もし Rust が真の FP 寄りに進化するとしたら”という観点で、欲しいものを列挙します。

### 6.1 効果型（Effect Types）

- `fn f(x: T) -> U !{IO, State}` のような形で副作用集合を持つ
- 効果のサブタイピング/多相性
- 効果ハンドラによる局所化

### 6.2 HKT（型コンストラクタ抽象）

- `trait Functor<F<_>> { ... }` のような抽象
- それに伴う、より自然な合成パターン

### 6.3 より強い型推論（ただし説明可能なエラーで）

- 注釈量を減らし、抽象の導入コストを下げる

### 6.4 スタック安全な再帰（TCO 保証 or 代替）

- 末尾呼び出し最適化の仕様化
- あるいは言語機構としてのトランポリン/継続

### 6.5 遅延の第一級サポート（選択的に）

- `lazy` 値・遅延パターン
- strictness を明示できる

### 6.6 永続データ構造の標準化

- `std::persistent::Map` のように“標準の不変コレクション”がある

### 6.7 合成のための構文糖衣

- パイプ演算子、部分適用、合成演算子
- これらは実用上の学習コストも下げる

---

## 7. 重要な補足：Rust で「真の FP」が“難しい”というより「目的が違う」

Rust は、

- **副作用を禁止する** のではなく
- **副作用を安全に扱える**
  ことを目標にしています。

このため、

- “言語が純粋性を強制し、効果を型で追跡する”
  という路線とは自然にズレます。

逆に言えば、Rust は

- 低レベル制御と高い抽象の両立
- 所有権による資源安全
- ゼロコスト抽象
  を重視することで、関数型言語とは別の価値を提供しています。

---

## 8. まとめ（不足点の一覧）

最後に、本文の不足点を「箇条書きのチェックリスト」としてまとめます。

### 8.1 言語機構

- [ ] 純粋性の強制・副作用追跡（Effect System / Purity）
- [ ] 代数的効果とハンドラ（効果の合成の言語サポート）
- [ ] 高階型（HKT）
- [ ] より強力で一貫した型推論（抽象が増えても注釈が最小）
- [ ] 遅延評価が既定（または第一級で自然）
- [ ] TCO 保証などの再帰中心スタイルの支援
- [ ] 関数合成・パイプ・部分適用などの標準構文
- [ ] 永続データ構造を前提にした最適化・型/ランタイム統合

### 8.2 標準/文化

- [ ] 永続コレクションの標準化
- [ ] Optics（Lens 等）の一般的な標準パターン
- [ ] 効果合成の統一的設計（分散しがちな合成モデルの統合）
- [ ] 合成前提の最適化（fusion/deforestation）を後押しする仕組み

---

## 付録：この文書の読み方（実用のヒント）

- 「Rust で関数型スタイルを実用的に使う」だけなら、Rust はすでに十分強力です。
- ここで挙げた不足は「純粋関数型言語と同じ“言語の強制力”を求めた場合」に顕在化します。
- つまり多くは“欠陥”ではなく“設計の優先順位の違い”です。
